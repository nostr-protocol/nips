NIP-24
======

Sealed Private Messages and Private Group Chats
-----------------------------------------------

`draft` `optional` `author:vitorpamplona` `author:kieran` `author:paulmillr` `author:staab`

This NIP creates a metadata-minimized encrypted messaging protocol for direct messages and closed group chats with the following privacy guarantees: 
1. Messages are encrypted to each participant's public key individually. 
2. Chat participant identities, each message's real date and time, event kinds, and other tags are all hidden from the public.
3. Senders and receivers cannot be linked with public information alone.
4. Minimal trust in counterparties: Counterparties cannot expose verifiable details of your message, including the metadata, without exposing their entire profile (private key)
5. There is no central queue, channel or otherwise converging event id to link or count all messages in the same group. 
6. There is no moderation role (i.e. no group admins, no invitations or bans)
7. There is no chatroom secret that can leak or be mistakently shared
8. Messages can be fully recoverable in any client with the receiver or the sender's private key
9. Users and clients can opt-in for "Disappearing Messages" that are not recoverable with their private key
10. The protocol's messages can flow through public relays without loss of privacy. Private relays can increase privacy further, but they are not needed.
11. The protocol is extensible to make any other event kind fully private (private likes, private reports, private long-form content, etc)

The resulting protocol is a convergence of many past proposals, including [NIP-44](https://github.com/nostr-protocol/nips/pull/574), [NIP-59](https://github.com/nostr-protocol/nips/pull/468), [NIP-24](https://github.com/nostr-protocol/nips/pull/56), [NIP-103](https://github.com/nostr-protocol/nips/pull/499), [NIP-76](https://github.com/d-krause/nostr-nips/blob/nip76-draft-2/76.md). It brings their best ideas together in a slighly different approach. 

## Overview

This protocol uses two main concepts to protect the transmission of a target event: Sealed Gossip Events and Gift Wraps ([NIP-59](https://github.com/nostr-protocol/nips/pull/468)). The target event is first **unsigned** (to make it unverifiable if it leaks -> "Gossip"), then Sealed, and then GiftWrapped.

As an early example: this is the flow of a private message: 

1. Target Event   `To Receiver: "Hi Receiver, did you finish the transfer? -- Signed, Sender"`
2. Gossip         `To Receiver: "Hi Receiver, did you finish the transfer? -- From Sender" (unsigned)`
3. Sealed Gossip  `<ENCRYPTED Gossip> -- Signed, Sender`
4. Gift Wrap      `To Receiver: <ENCRYPTED Sealed Gossip> -- Signed, Anon`

The Gift Wrap is the only event sent to relays. 

Any event kind can be made a Gossip by removing the signature. 

## 1. A new ChatMessage Kind as Gossip

This NIP defines `Kind:14` as a Chat Message in a similar way `Kind:4` does, but it's never signed and if it is signed, the information in it is **fully public**. This event requires the rest of the protocol to make it private. Any other kind may be wrapped in the same way as a kind 14 following the steps described below in order to implement any other kind of private data transfer.

Direct Message Payload: 
```js
{
  "id": "<The usual hash>",
  "pubkey": "<author key in hex>",
  "content": "This is a DM",
  "kind": 14,
  "created_at": 1686840217,
  "tags": [ <one or more receivers, mentions, citations, additional fields like content-sensitivity, etc> ],
}
```

## 2. The Sealed Gossip Event Kind

A Sealed Gossip is a `kind:13` event that wraps an unsigned event (the Gossip) with the sender's regular key. The Sealed Gossip is **always** encrypted to a receiver's pubkey but there is no `p` tag pointing to the receiver. There is no way to know who the Gossip is for without the receiver's or the sender's private key. The only public information in this event is who is signing it. 

```js
{
  "id": "<The usual hash>",
  "pubkey": "<Real Author's PubKey>",
  "content": "<XCHACHA-Encrypted Gossip Kind>",
  "kind": 13,
  "created_at": 1686840217,
  "tags": [],
  "sig": "<Real Author's PubKey Signature>"
}
```

Tags MUST must always be empty in a `kind:13`, 

The inner event MUST always be unsigned 

The encryption algorithm MUST use a versioned payload with a XChaCha cipher. 

## 3. Gift Wrap Event Kind

A GiftWrap event is a `kind:1059` event that wraps any other event with a single use (random) key and is `p`-Tag-addressed to the receiver.

The goal is to hide the sender's information, the metadata, and the content of the original event from the public. The only public information is the receiver's public key. Clients pull all GiftWraps citing their user, decrypt the gift-wrapped event with the user's private key, and use the inner event as usual. The inner event is signed by the known author. 

Gift wraps alone are an effective tool to hide information from the public. However, the inner event can be easily re-broadcasted, breaking the privacy of the sender and leaking its metadata (e.g. author, event kind, dates, tags, etc). The GiftWrap MUST wrap a Sealed Gossip Event to make sure the receiver cannot break the privacy guarantees when re-broadcasting it. 

```js
{
  "id": "<The usual hash>",
  "pubkey": "<Random, one-time-use PubKey>",
  "content": "<XCHACHA-Encrypted Kind 13>",
  "kind": 1059,
  "created_at": 1686840217,
  "tags": [
    [ "p", "<Receiver>" ]
  ],
  "sig": "<Random, one-time-use PubKey Signature>"
}
```

A `p` tag for the recipient MUST be added to the `tags` field of a GiftWrap. This is how clients will download incoming "things". Other tags should not be added to this event. 

## 4. Encrypting with XChaCha (former NIP-44)

Encryption is made with the SHA-256 hash of the shared secret between a private and a public key. 

First, serialize the event to JSON. Then acquire the shared secret, a 24-byte nonce, and encrypt it with a XChaCha cipher (XChaCha is different than ChaCha). Convert both the nonce and the resulting byte array to Base64 and output an object with the following fields: 

```js
{
  "ciphertext": "<Base64-encoded ByteArray>"
  "nonce": "<Base64-encoded Nonce>"
  "v": <Version Code>  
}
```

Field `v` determines the algorithm version to be used. Current versions are: 
 - `0`: Reserved
 - `1`: XChaCha20
 
The stringified version of this object goes into the `.content` of the GiftWrap and Sealed Gossip events.  
 
## 5. Private Message Algorithm

To send a private message, create a kind `Kind:14` with the message in its `.content` and a p-Tag to the receiver. Other tags are encouraged to be added, such as `content-sensitivity` if the content is NSFW and `subject` to create a name to the conversation. 

Once `Kind:14` is created, remove the signature and serialize as JSON. Encrypt the serialized `Kind:14` to the receiver's public key and seal it with a `kind:13` event, signed by the sender's main key. 

For each receiver: 

1. Create a new key, serialize the seal, and encrypt it into a `kind:1059` with a tag to the receiver, signed by the new random key. 
2. Broadcast the `kind:1059` event to the relays of the receiver. 

For the sender: 

1. Create a new key, serialize the seal, and encrypt it into a `kind:1059` with a tag to the sender, signed by the new random key. 
2. Broadcast the `kind:1059` event to the relays of the sender. 

## 6. Private Group Chat Algorithm

Private Group chats are `Kind:14`s for more than one `p` tag. There is no channel definition event. The set of authors + recipient keys defines a group.

To send a private message to a group, create a kind `Kind:14` event with the message in its `.content` and add a p-Tag to each receiver. Other tags are encouraged to be added, such as `content-sensitivity` if the content is NSFW and `subject` to create a name to the conversation. Once `Kind:14` is created, remove the signature and serialize it as JSON.

For each receiver: 

1. Encrypt the serialized `Kind:14` to the **receiver's public key** and seal it with a `kind:13` event, signed by the sender's main key. 
2. Create a new key, serialize the seal, and encrypt it into a `kind:1059` with a tag to the **receiver**, signed by the new random key. 
3. Broadcast the `kind:1059` event to the relays of the **receiver**. 

For the sender: 

1. Create a new key, serialize the seal, and encrypt it into a `kind:1059` with a tag to the **sender**, signed by the new random key. 
2. Broadcast the `kind:1059` event to the relays of the **sender**. 

Clients SHOULD render every distinct set of author + recipient pubkeys as a group with continuing conversations. If a new p tag is added, a new group is created. 

The `subject` tag defines any name for the group or the current topic of the discussion. Any member of the group can change the subject. 

## 7. Final Considerations

This proposal makes heavy use of one-time keys to elevate the privacy design of Nostr messages. It can be applied to any Nostr event kind (e.g. private reactions), but the focus here is on private messages. For instance, the use of a Gossip Event enhances a paid-subscriber-only event kind by making it difficult (not impossible) to leak the paid content in a publicly verifiable payload. 

It's worth noting that the only created_at time that matters is with the Gossip event. All the other time-attributes SHOULD be tweaked to reduce the time-collision of send and receive Gift Wraps and Sealed Events.

Relays may choose not to store gift wrapped events due to them not being publicly useful. Clients MAY choose to attach a certain amount of proof-of-work to the wrapper event per NIP-13 in a bid to demonstrate that the event is not spam or a denial-of-service attack.

To protect recipient metadata, relays SHOULD only serve kind 1059 events intended for the marked recipient. When possible, clients should only send wrapped events to read relays for the recipient that implement AUTH, and refuses to serve wrapped events to non-recipients.

## 8. Private Group Chat, Step by Step

Let's send a message from `5b107933d9520411dbc6ed9ece42bbec8b930978671a6e9782528a74d70eb5e6` to `2f27f7d08bd618c4c9a050d923ed915a693ecb3e5d399b26ef0829f29a51035f` and `2f3b57b49531b5fc714307f53eda525eacf1733f5dc30e9c2ac57b60045c3e28`, asking "Who is going to the party tonight?"

### 8.1. Create a ChatMessage event

Create a `kind:14` with the message, the receivers, and any other tags you want, signed by the author. 

```json
{
   "content":"Who is going to the party tonight?",
   "created_at":1690665694,
   "id":"78e9f512a4fc220d3944e85d2b67b89ff16cf27fcdc415782673ef802fda14ce",
   "kind":14,
   "pubkey":"5b107933d9520411dbc6ed9ece42bbec8b930978671a6e9782528a74d70eb5e6",
   "sig":"0ec56353a13e44ba3cec6fea4aed278b486d92ed51880b17ddef8c93bb44cc1789d4747d242aeb80cb32b0c61974294e875492043e83c81fa6e9f700981e7a61",
   "tags":[
      [ "p", "2f27f7d08bd618c4c9a050d923ed915a693ecb3e5d399b26ef0829f29a51035f" ],
      [ "p", "2f3b57b49531b5fc714307f53eda525eacf1733f5dc30e9c2ac57b60045c3e28" ]
   ]
}
```

### 8.2. Make it a Gossip

Remove the signature to make it unverifiable if leaked.

```json
{
   "content":"Who is going to the party tonight?",
   "created_at":1690665694,
   "id":"78e9f512a4fc220d3944e85d2b67b89ff16cf27fcdc415782673ef802fda14ce",
   "kind":14,
   "pubkey":"5b107933d9520411dbc6ed9ece42bbec8b930978671a6e9782528a74d70eb5e6",
   "tags":[
      [ "p", "2f27f7d08bd618c4c9a050d923ed915a693ecb3e5d399b26ef0829f29a51035f" ],
      [ "p", "2f3b57b49531b5fc714307f53eda525eacf1733f5dc30e9c2ac57b60045c3e28" ]
   ]
}
```

### 8.3. For each of the 3 participants

#### 8.3.1. Seal the Gossip
   
Encrypt the JSON-Stringified Gossip with the **Sender**'s key to the participant, create a `kind:13` event and sign it with the **Sender**'s key

```json
{
  "content":"{\"ciphertext\":\"afjDsXGCX/Zk7S79rSYUC/uqRlIvqVRQ8R2uOXlAYinCVSM7J+lLYSYJI3CwYzh+w9LapmqFrBi69KRZVsRsukiooAISpN0R2hx1lRSq2zmjD7reHIExuvnMvXHc0Ts0O1QtC7Uopc9v21H5BByh3+NIe51lprDZ01RtAczXBC75r/uSUTQmYK924Qu9VmFb/Ky/76gvPPlM/Y4bO6V7MGf52AOFPLuBCJuL20X1MYD4mwuvnMo0gW4dP2AuRAefzwva9exjSaN8qw0qeLRKifof5dgx8TOAr2Vwmd06HiEFdkr/iKuq5YZn9W7ghbknPvpsbY5KD/Ewli0HpkvGUHAdpi/cN9PGkrDH15AmukA0H247GWghF22l6+vqwJq6DAvgeyigwcJyywJfCHSF6drJi4Jx3dnE7JBymw1CNED10b4snxID6fNpJAChUpIssaxsYJ40xTi2dEVFX2zV10i1MpivMCvRRijsZTNSMWhfWPvfIeCxxp57AnWd148V\",\"nonce\":\"mWsJ13BlM0yercWZsGeYWeIdjVK+ekgr\",\"v\":1}",
  "created_at":1690665694,
  "id":"1addecbdfc796722614470c598d5b19b48a75e97af3c442d7622f16170414b01",
  "kind":13,
  "pubkey":"5b107933d9520411dbc6ed9ece42bbec8b930978671a6e9782528a74d70eb5e6",
  "sig":"2ce18939a0152600b00b546ab945b88c4c4ec0d0fa850f31c4a0e2f09ef29a6450859cd19d548cc8b12fd5e339bc8b61a317fcd27cbde33f7f4a9c936ca003fd",
  "tags":[]
}
```
	
Notice how there are no tags declared in this event. 

#### 8.3.2. Get a Random Key 

We are using `4f02eac59266002db5801adc5270700ca69d5b8f761d8732fab2fbf233c90cbd` in this example

#### 8.3.3. Create the Gift Wrap
   
Encrypt the JSON-Stringified `kind:13` with the Random key and create a Gift Wrap event for the participant

```json
{
  "content":"{\"ciphertext\":\"KTH+rnuBvqkGRpTO+UsvPk42oh4b6/R1u6L35usrq9/MMfQG4L+ejXnFlrJcZFqyTfJOZz2jTg74/0Lf7BfBcAWugnO130U4VObS4Sqg9/2wZgBEHiZSXb6B12Z+Z5R9AOJfDE0tGYQbcsbUwTTk+a24G53LeKYOZUp6bnz2ssi0GrfQPzAo7mY0As4sdRBXWO5GprAwEBkMJy6/oBQa9Kiapb/7moOno1VRH0slW+ckFL1LxzQye4L0ige3UuzHYhUAJLdFZi+w4quTsN7VlyUPUsoVQdrWc83EHrhEuS0o10NpBare9ZseLVaKJm+oJrq7QOhvzaZA7Dhzx0U9Uth03ALkjw42BBq2d+QtFnidMrUo2QBtw+DcsS1fFQXF6sH+NGt+t7nmf9PFo95OtZsU1+ZHeZGk1mIj0HUb2CkEXAzhD3mvp6N8CjRVQ3Ewu4by5jP2y1nsmXNO5wokaflAR+u8COm1DycNFcVuQJnfgoSMsKv19wWZi2OZ8Bx2hILsZNHmqIphDDOkkyE8x/enCOK5BmCiq6UQ6uJVRvIS8GVg+AmmeC1NwdDsZJXLyOVAa/YGCuKxhZkFWmc5P5U4ushlf4CmFyz4LYJmh8StjIl1eqgoa5x4GkxEaaWVSDn34eqrITeLGgMUNsqElkFxyABafMMa0DnufJfGOG1J6Frd63St+e6JgeXpr32KWwFe9aQc8xX9B5IarMqrRrKze4sTo0gBrzurR1rYqzip++ppcZfh8iE6zSnBlt9j04D4El3MIOij4Y749Rhh+QRtDieXXmWkzYpeF5780IEorSfovXzKBjpRUe+r6LREXduFjCpsthWbSN86oisllouiNqtHD/CP+6+MMV5xpGzVffuLtArcJq7OBtomnzdtAKSXpbfOtPE3/UUeFCgfxO6J80aevGbpGw82CoYzCwKOf5pShi357F7uV0pc9LQtD4Rrq/ChvFDjcFpD3XGzIx9a49/Q68SO4fAeDJ3lbSjgKl+AZZHRU0w017V+w2fzJydpcyUJAEv3RBhnurUAexgx+V2zmUTcGq9ZkLJB9+l1s2Qthyn0hVKs0lxXf5Z6PT+qufKMnyuUqg5b29EM1iXnD23cJGaPvFhYtwVGf2K9B3lZHDJXt/dL+PHFc2mMii9kjJiJGTsBNbYMW6smtmkm0I8jR77AVefQoSNRRR+7JFP5rCP3UmyW1215g6dJmwKkY9XWkzTldLsDI0WCxMBsjQ==\",\"nonce\":\"zyQcHsrxa0cDiWgGYuVc0LDDNn7b8NL5\",\"v\":1}",
  "created_at":1690665694,
  "id":"aa85f7c0dffd83a4474b3488fe443a53f75793c975a13fb25452798c7300ccf9",
  "kind":1059,
  "pubkey":"4f02eac59266002db5801adc5270700ca69d5b8f761d8732fab2fbf233c90cbd",
  "sig":"95b12fc477210748b447b3b7c8393a1b2ef5b1685122d0345534378d8ef8d2af4b05c1d403c12601d6ddc27e661e4a4452d6d0d676f38ff8a48feff8648d4b92",
  "tags":[
    [ "p", "2f27f7d08bd618c4c9a050d923ed915a693ecb3e5d399b26ef0829f29a51035f" ]
  ]
}
```
	
Notice that the signer is a random key.

#### 8.3.4. Broadcast Selectively
   
Broadcast the `kind:1059` event to the participant's relays only. Delete all the other events. 

## 9. Encryption Code Examples

### 9.1. JavaScript

```js
import type {UnsignedEvent, Event} from 'nostr-tools'
import {getPublicKey, getEventHash, getSignature, generatePrivateKey} from "nostr-tools"
import {xchacha20} from '@noble/ciphers/chacha'
import {secp256k1} from '@noble/curves/secp256k1'
import {sha256} from '@noble/hashes/sha256'
import {randomBytes} from '@noble/hashes/utils'
import {base64} from '@scure/base'

export const fromHex = hex => Uint8Array.from(hex.match(/.{1,2}/g).map(byte => parseInt(byte, 16)))

export const now = (drift = 0) => {
  const t = Math.round(Date.now() / 1000)
  const factor = Math.pow(10, drift)
  const offset = factor - Math.round(factor * Math.random()) * 2

  return t + offset
}

export const utf8Decoder = new TextDecoder()

export const utf8Encoder = new TextEncoder()

export const getConversationKey = (privkeyA: string, pubkeyB: string): Uint8Array =>
  sha256(secp256k1.getSharedSecret(privkeyA, '02' + pubkeyB).subarray(1, 33))

export const getNonce = () => base64.encode(randomBytes(24))

export type Nip44Payload = {
  ciphertext: string
  nonce: string
  v: 1
}

export function encrypt(key: Uint8Array, text: string, v = 1): Nip44Payload {
  if (v !== 1) throw new Error('NIP44: unknown encryption version')

  const nonce = randomBytes(24)
  const plaintext = utf8Encoder.encode(text)
  const ciphertext = xchacha20(key, nonce, plaintext)

  return {
    ciphertext: base64.encode(ciphertext),
    nonce: base64.encode(nonce),
    v,
  }
}

export function decrypt(key: Uint8Array, data: Nip44Payload): string {
  if (data.v !== 1) throw new Error('NIP44: unknown encryption version');

  const nonce = base64.decode(data.nonce)
  const ciphertext = base64.decode(data.ciphertext)
  const plaintext = xchacha20(key, nonce, ciphertext)

  return utf8Decoder.decode(plaintext)
}

export const createRumor = (pubkey, {content, recipients, subject}) => {
  const rumor = {
    pubkey,
    content,
    kind: 14,
    created_at: now(),
    tags: recipients.map(k => ["p", k]).concat([["subject", subject]]),
  } as any

  rumor.id = getEventHash(rumor)

  return rumor as UnsignedEvent & {id: string}
}

export const createSeal = (privkey: string, pubkey, rumor) => {
  const sealKey = getConversationKey(privkey, pubkey)
  const content = JSON.stringify(encrypt(sealKey, JSON.stringify(rumor)))

  const seal = {
    content,
    kind: 13,
    created_at: now(5),
    pubkey: getPublicKey(privkey),
    tags: [],
  } as any

  seal.id = getEventHash(seal)
  seal.sig = getSignature(seal, privkey)

  return seal as Event
}

export const createGift = (pubkey, seal, privkey) => {
  const burnerKey = generatePrivateKey()
  const conversationKey = getConversationKey(burnerKey, pubkey)
  const content = JSON.stringify(encrypt(conversationKey, JSON.stringify(seal)))

  const gift = {
    content,
    kind: 1059,
    created_at: now(5),
    pubkey: getPublicKey(burnerKey),
    tags: [["p", pubkey]],
  } as any

  gift.id = getEventHash(gift)
  gift.sig = getSignature(gift, burnerKey)

  return gift as Event
}

### Kotlin

```kotlin
// implementation 'fr.acinq.secp256k1:secp256k1-kmp-jni-android:0.10.1'
// implementation "com.goterl:lazysodium-android:5.1.0@aar"
// implementation "net.java.dev.jna:jna:5.12.1@aar"

fun getSharedSecretNIP24(privKey: ByteArray, pubKey: ByteArray): ByteArray =
  MessageDigest.getInstance("SHA-256").digest(
    Secp256k1.get().pubKeyTweakMul(
      Hex.decode("02") + pubKey,
      privKey
    ).copyOfRange(1, 33)
  )

fun encryptNIP24(msg: String, privKey: ByteArray, pubKey: ByteArray): EncryptedInfo {
  val nonce = ByteArray(24).apply {
    SecureRandom.getInstanceStrong().nextBytes(this)
  }

  val cipher = streamXChaCha20Xor(
    message = msg.toByteArray(),
    nonce = nonce,
    key = getSharedSecretNIP24(privKey, pubKey)
  )

  return EncryptedInfo(
    ciphertext = Base64.getEncoder().encodeToString(cipher),
    nonce = Base64.getEncoder().encodeToString(nonce),
    v = Nip24Version.XChaCha20.code
  )
}

fun decryptNIP24(encInfo: EncryptedInfo, privKey: ByteArray, pubKey: ByteArray): String? {
  require(encInfo.v == Nip24Version.XChaCha20.code) { "NIP44: unknown encryption version" }

  return streamXChaCha20Xor(
    message = Base64.getDecoder().decode(encInfo.ciphertext),
    nonce = Base64.getDecoder().decode(encInfo.nonce),
    key = getSharedSecretNIP24(privKey, pubKey)
  )?.decodeToString()
}

// This method is not exposed in AndroidSodium yet, but it will be in the next version.
fun streamXChaCha20Xor(message: ByteArray, nonce: ByteArray, key: ByteArray): ByteArray? {
  return with (SodiumAndroid()) {
    val resultCipher = ByteArray(message.size)

    val isSuccessful = crypto_stream_chacha20_xor_ic(
      resultCipher,
      message,
      message.size.toLong(),
      nonce.drop(16).toByteArray(), // chacha nonce is just the last 8 bytes.
      0,
      ByteArray(32).apply {
      crypto_core_hchacha20(this, nonce, key, null)
      }
    ) == 0

    if (isSuccessful) resultCipher else null
  }
}

data class EncryptedInfo(val ciphertext: String, val nonce: String, val v: Int)

enum class Nip24Version(val code: Int) {
  Reserved(0),
  XChaCha20(1)
}
```

## Test Cases

Created with Amethyst. The receiver's Private Key is `de6152a85a0dea3b09a08a6f8139a314d498a7b52f7e5c28858b64270abd4c70`

```json
 {
    "content":"{\"ciphertext\":\"AaTN5Mt7AOeMosjHeLfai89kmvW/qJ7W2VMttAwuh6hwRGV+ylJhpDbdVRhVmkCotbDjBgS6xioLrSDcdSngFOiVMHS5dTAP0MkQv09aZlBh/NgdmyfHHd24YlHPkDuF5Yb4Vmz7kq/vmjsNZvDrTen3TG2DcEoTV9GKexdMEqyBA4LsB2DLnWfpvOi0olDkGjPGSteTaU1nCdOtN8knoEKumrxwevvbygKphorvKX/j3ojMMb0AceJM6Cr6TRIvSsQnKGEv5V8qbC/uIrQoH3N108Fd/2SY2MWuyLKRnuak9F/w82MV13elq8ngyjcktLYM5yrPg5nrxZlyJsV8D7V/g/bvhoL+UmWe0XoCR5LXzy77SfIkgA1ePKEfGp5sD2CVIzXt9zHdFwGxAKZuyB4qwrRaAFrS2xx+Bw4nnEmF6V9NhfheSCmGzTILuTePx4ubvnYw/j8Hmqd6UvM3DBNnlJ3D6po0blirfWvMe/ea+Em4CMXfq8Iq+7r4gRx8azADygKeJ+C89GTBEvS9EvgrXCVfTMVTcFc44YAZhekOqYY1BOZgfxIV4gUiJfpMMd4B9MQv/tmnewrpTsq1reSQQcEW/mXT2cnMeCZbAIJSPg8usZ30QlrH+np+YSzFKWYDP1kThcV0ElEE2Ne8KaUUFIRE5KmhBQc/qtORefCpne5s7V7J5vLjT5rinsDzzENB1XVlmY1Icx42raP5tGAL1gOK5gRHLvtcgFQR3WcDRYaNqELiYxx41j9w9lz5e00Ttla255rZkb760KSLaBFBss6wYGiYCabVgtBNpkExpCFPPEd5eAZa5rNK2QrnojYsdxEnlicF6A+zSChLy/TbzxYwyQywDfoF9F8kBakPZkAhsciQViCii2KlieRq4OgJFZGndmnS82hyPqsoJIm22vWr1iqMvSBHo/9cLj/r+lfmGVOdgM62JHckPZjOLS0QWIb9gQiT+zXZG22+eZElMYbGXVpR1dyMaQtde8ivEVVLas6kMCVKaDTHEFglaCBXjJ3RNJv73HsG1kb0rMmOj8ltbBakjHpv7M59amavuu6SReYt\",\"nonce\":\"6anNjUdNwW6MNfoKzRZcz1R09N1h8G4L\",\"v\":1}",
    "created_at":1690660515,
    "id":"d90739741c2f5a8c1a03aab5dc219c0b708ed6b0566044495731cd0307cf19a5",
    "kind":1059,
    "pubkey":"a79b7162f8ebb9c9f7aa65a48977ab7f32aa097520bc543e4d625812154ff6af",
    "sig":"9b012504e779632a2a1f55562fa9a85f8ae6245cbc149b83d25b2971249053abc77f65cc068e5d025b871d743678265fede70de4eaf5af642e675a5b6210077d",
    "tags":[
       [
          "p",
          "c55f0b0cb4dd180dd4395867b28dd4c208b709144a69fb7c31a46c369a5ad1c6"
       ]
    ]
 }
```

