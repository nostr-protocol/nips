NIP-06
======

Basic key derivation from mnemonic seed phrase
----------------------------------------------

`draft` `optional`

[BIP39](https://bips.xyz/39) is used to generate mnemonic seed words and derive a binary seed from them.

[BIP32](https://bips.xyz/32) is used to derive the path `m/44'/1237'/<account>'/0/0` (according to the Nostr entry on [SLIP44](https://github.com/satoshilabs/slips/blob/master/slip-0044.md)).

A basic client can simply use an `account` of `0` to derive a single key. For more advanced use-cases you can increment `account`, allowing generation of practically infinite keys from the 5-level path with hardened derivation.

Other types of clients can still get fancy and use other derivation paths for their own other purposes.

### Test vectors

mnemonic: leader monkey parrot ring guide accident before fence cannon height naive bean\
private key (hex): 7f7ff03d123792d6ac594bfa67bf6d0c0ab55b6b1fdb6249303fe861f1ccba9a\
nsec: nsec10allq0gjx7fddtzef0ax00mdps9t2kmtrldkyjfs8l5xruwvh2dq0lhhkp\
public key (hex): 17162c921dc4d2518f9a101db33695df1afb56ab82f5ff3e5da6eec3ca5cd917\
npub: npub1zutzeysacnf9rru6zqwmxd54mud0k44tst6l70ja5mhv8jjumytsd2x7nu

---

mnemonic: what bleak badge arrange retreat wolf trade produce cricket blur garlic valid proud rude strong choose busy staff weather area salt hollow arm fade\
private key (hex): c15d739894c81a2fcfd3a2df85a0d2c0dbc47a280d092799f144d73d7ae78add\
nsec: nsec1c9wh8xy5eqdzln7n5t0ctgxjcrdug73gp5yj0x03gntn67h83twssdfhel\
public key (hex): d41b22899549e1f3d335a31002cfd382174006e166d3e658e3a5eecdb6463573\
npub: npub16sdj9zv4f8sl85e45vgq9n7nsgt5qphpvmf7vk8r5hhvmdjxx4es8rq74h

Cold storage for Nostr secret keys
----------------------------------

`draft` `optional`

Based on the well known [BIP-39 word lists](https://raw.githubusercontent.com/bitcoin/bips/master/bip-0039/bip-0039-wordlists.md), which 
encode 11 bits per word, it is possible, with 24 words, to precisely encode 
a 32 byte nostr secret key.

The foregoing method does not provide any utility for cold storage backup 
purposes or offline keys or airgapped signing devices with easy usability 
for humans

Where the key was generated previously and for reasons of ongoing use or for 
vanity npubs there is a need to have a human-friendly transcription that 
preserves the exact secret key.

This scheme can thus be applied to any existing `nsec` and enables backing 
up of these keys without their error-prone encoding or being on internet 
connected or un-isolated devices.

### Details of the protocol

With 11 bits per [BIP-39 word list](https://raw.githubusercontent.com/bitcoin/bips/master/bip-0039/bip-0039-wordlists.md) 
word, without the complication of padding one can encode multiples of 88 
bits per 8 words.

The nearest larger multiple of 88 is 264, which is precisely 8 bits more 
than needed to encode a 256 bit secret key.

8 bits does not provide very strong check strength but at the same time, 
word key mis-transcriptions basically are very unlikely, as the word list 
was chosen deliberately to make it possible to infer the correct ciphers 
where there is a misspelling, by a partial match.

A simple checksum that simply takes the first byte of the SHA256 hash of the 
secret key is simple to generate, and can be attached to the secret prior to 
converting to the word ciphers format.

#### Reference Implementation

The simplest implementation, as found [here](https://github.com/mleku/wordstr) 
uses large integer division and modulo operations to break the key into 11 
bit values by dividing by 2048, accumulating the remainder (modulo) value in 
order, and then substituting the remainder value for the word key value.

The disadvantage of using this method of deriving the 11 bit cipher form of 
the 264 bit value is that leading zeroes can cause the actual bytes to 11 
bit value correspondence to be shifted around, and the simplest way to avoid 
this is by making the most significant bit a 1.

#### Derivation from Key via Long Division and Remainders

So, keeping in mind these considerations, and because large integer division 
and modulo is almost universally available in most programming languages, 
the MSB is forced to 1, which is equivalent to the first byte being bitwise 
OR with 128, which is the most significant bit of a byte.

The first byte of the SHA256 hash of the key value can then be modified with 
this bitwise operation, affording 7 bits of error check, which is plenty for 
a cipher with low transcription error probability.

#### Decoding Mnemonic Key back to Secret Key

Decoding the words first the array of the index of each word in the cipher 
according to its' position in the word list then are gathered, and this 
value is multiplied by the places, which are generated by starting with one 
and each subsequent place in the key is the exponent of 2048, that is, 1, 
2048, 2048*2048, and each subsequent field additionally multiplied by 2048 
until you get 24.

Then, reverse this array or iterate it backwards and multiply by the index 
of each word key, and sum these products to derive the original large integer.

Once you have the original large integer, convert it back to the form of 33 
bytes.

#### Verifying the Checksum

The first (most significant) byte is the check, and the most significant 
bit (bit 8) is set to one, so by hashing the rest of the bytes, and taking 
the first byte of the hash, performing a bitwise OR with the number 128 on 
this byte, and comparing this calculated value to the actual first byte of 
the decoded key, provides 7 bits of checksum that the rest of the key is as 
it was supposed to be, when these two bytes are equal, the key is as intended.

It is not a strong checksum, but the awkward 11 bit encoding makes any other 
option a lot more complicated to implement, and the algorithm is of 
sufficiently low complexity that a very small execution environment with 
several kilobytes of working memory and the required ~16kb for the word 
index can be practically done, a minimum of 24kb would probably be realistic.

Because the chances of a mis-transcription are already very low, and such a 
mis-transcription having a valid check (1/128 chance) this should be 
sufficient.