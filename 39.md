NIP-39
======

External Identities in Profiles
-------------------------------

`draft` `optional`

## Abstract

Nostr protocol users may have other online identities such as usernames, profile pages, keypairs etc. they control and they may want to include this data in their profile metadata so clients can parse, validate and display this information.

## `i` tag on a metadata event

A new optional `i` tag is introduced for `kind 0` metadata event contents in addition to name, about, picture fields as included in [NIP-01](https://github.com/nostr-protocol/nips/blob/master/01.md):

```jsonc
{
  "kind": 0,
  "tags": [
    ["i", "github:semisol", "9721ce4ee4fceb91c9711ca2a6c9a5ab"],
    ["i", "twitter:semisol_public", "1619358434134196225"],
    ["i", "mastodon:bitcoinhackers.org/@semisol", "109775066355589974"],
    ["i", "telegram:1087295469", "nostrdirectory/770"],
    ["i", "openpgp4fpr:1a04e0f1a78d982bd8885b7eb325a9c5f70849d0", "owGbwMvMwCW2WXXl0e8cnhcYTzcmMaRNrekJSy3KTKvMzEtXKMlILFHwVEjOzyspys8BclMV0vJzcvLLQZJ++cUlRQoFpUk5mckK2amVVgpKeUCeYXmaSUFpWnFpcmqRaVmiRbplgUFRlmlKXkZZWmqGWYpFuUG6WWpiZWJqgWlKRkGxWVFxerGJcUp6hqUSV0cpC4MYF4OsmCKLFMuDj8t7Z2jf6IiugzmRlQnkPgYuTgGYyPY+hv9+FpdPrH+Zwn+hW5PfqcSoW2vFk08zM0xNtfXL7jRdmcLNyLB/Z3/a2cryx7NfyazK+Z/w2aWqcG+tiFz5lMtRUZuDlvEAAA==", "mDMEZgHdOxYJKwYBBAHaRw8BAQdA6pZgdsmDviRF45Cc+9MBb+udQDYgfGF6kBBUMByGxKa0F2ZyYW56YXAgPF9AZnJhbnphcC5jb20+iJMEExYKADsWIQQaBODxp42YK9iIW36zJanF9whJ0AUCZgHdOwIbAwULCQgHAgIiAgYVCgkICwIEFgIDAQIeBwIXgAAKCRCzJanF9whJ0L9GAQCuEPQtioDtiJicUHl8KDjSGfEMehAVv6lLbnd0SF3z/AD+PebBpY7bL/jF8BubiO+VogmHlkcFgxyWfD060000oAo=", "1800000000"]
  ],
  // ...
}
```

An `i` tag will have two or more parameters, which are defined as the following:
1. `type:identity`: This is the platform name (for example `github`) or the linked cryptographic identity type (for example `openpgp4fpr`), and the identity on that platform (for example `semisol`) or public key fingerprint (for example `1A04E0F1A78D982BD8885B7EB325A9C5F70849D0`) joined together with `:`.
2. `proof`: String that points to the proof of owning this identity or is the proof itself (cryptographic signature).

For cryptographic identity types (`openpgp4fpr`, `x509`), two additional parameters are required:
3. `pubkey`: The full public key material in base64 format.
4. `expiry`: Unix timestamp when the proof expires.

Clients SHOULD process any `i` tags with more than 5 values for future extensibility.
Identity provider names SHOULD only include `a-z`, `0-9` and the characters `._-/` and MUST NOT include `:`.
Identity names SHOULD be normalized if possible by replacing uppercase letters with lowercase letters, and if there are multiple aliases for an entity the primary one should be used.

## Revocation

The event MAY be updated by removing `i` tags that no longer apply.

## Claim types

### `github`

Identity: A GitHub username.

Proof: A GitHub Gist ID. This Gist should be created by `<identity>` with a single file that has the text `Verifying that I control the following Nostr public key: <npub encoded public key>`.
This can be located at `https://gist.github.com/<identity>/<proof>`.

### `twitter`

Identity: A Twitter username.

Proof: A Tweet ID. The tweet should be posted by `<identity>` and have the text `Verifying my account on nostr My Public Key: "<npub encoded public key>"`.
This can be located at `https://twitter.com/<identity>/status/<proof>`.

### `mastodon`

Identity: A Mastodon instance and username in the format `<instance>/@<username>`.

Proof: A Mastodon post ID. This post should be published by `<username>@<instance>` and have the text `Verifying that I control the following Nostr public key: "<npub encoded public key>"`.
This can be located at `https://<identity>/<proof>`.

### `telegram`

Identity: A Telegram user ID.

Proof: A string in the format `<ref>/<id>` which points to a message published in the public channel or group with name `<ref>` and message ID `<id>`. This message should be sent by user ID `<identity>` and have the text `Verifying that I control the following Nostr public key: "<npub encoded public key>"`.
This can be located at `https://t.me/<proof>`.

### `openpgp4fpr`

Identity: An OpenPGP fingerprint as described in the [openpgp4fpr URI scheme](https://metacode.biz/openpgp/openpgp4fpr), lowercased.

Proof: A binary signature of the text `Verifying until <expiry_unix_timestamp> that I control the following Nostr public key: "<npub encoded public key>"` converted to base64 format, unwrapped.

Public key material: The full, binary, non-ASCII, OpenPGP public key converted to base64 format, unwrapped.

Expiry: Unix timestamp when the proof expires.

#### Example

Using text `Verifying until 1800000000 that I control the following Nostr public key: "npub1wf4pufsucer5va8g9p0rj5dnhvfeh6d8w0g6eayaep5dhps6rsgs43dgh9"`

```jsonc
{
  "kind": 0,
  "tags": [
    ["i", "openpgp4fpr:1a04e0f1a78d982bd8885b7eb325a9c5f70849d0", "owGbwMvMwCW2WXXl0e8cnhcYTzcmMaRNrekJSy3KTKvMzEtXKMlILFHwVEjOzyspys8BclMV0vJzcvLLQZJ++cUlRQoFpUk5mckK2amVVgpKeUCeYXmaSUFpWnFpcmqRaVmiRbplgUFRlmlKXkZZWmqGWYpFuUG6WWpiZWJqgWlKRkGxWVFxerGJcUp6hqUSV0cpC4MYF4OsmCKLFMuDj8t7Z2jf6IiugzmRlQnkPgYuTgGYyPY+hv9+FpdPrH+Zwn+hW5PfqcSoW2vFk08zM0xNtfXL7jRdmcLNyLB/Z3/a2cryx7NfyazK+Z/w2aWqcG+tiFz5lMtRUZuDlvEAAA==", "mDMEZgHdOxYJKwYBBAHaRw8BAQdA6pZgdsmDviRF45Cc+9MBb+udQDYgfGF6kBBUMByGxKa0F2ZyYW56YXAgPF9AZnJhbnphcC5jb20+iJMEExYKADsWIQQaBODxp42YK9iIW36zJanF9whJ0AUCZgHdOwIbAwULCQgHAgIiAgYVCgkICwIEFgIDAQIeBwIXgAAKCRCzJanF9whJ0L9GAQCuEPQtioDtiJicUHl8KDjSGfEMehAVv6lLbnd0SF3z/AD+PebBpY7bL/jF8BubiO+VogmHlkcFgxyWfD060000oAo=", "1800000000"],
    // ...
  ],
  // ...
}
```

Example command to obtain a signature:

```bash
EXPIRY=$(date -d "+1 year" +%s)
echo -n "Verifying until ${EXPIRY} that I control the following Nostr public key: \"<npub>\"" | gpg --sign | base64
```

Example command to export the public key:

```bash
gpg --export name@example.com | base64
```

#### Client Verification

1. Extract `expiry` from tag[4]
2. Reconstruct message: `Verifying until <expiry> that I control the following Nostr public key: "<npub>"`
3. Verify signature (tag[2]) against public key (tag[3])
4. Check current time < expiry (warn if expired)

### `x509`

Identity: The X.509 certificate's SHA-256 fingerprint, lowercased.

Proof: A signature of the text `Verifying until <expiry_unix_timestamp> that I control the following Nostr public key: "<npub encoded public key>"` in base64 format, unwrapped.

Public key material: The full, binary, DER-formatted public key of the certificate converted to base64 format, unwrapped.

Expiry: Unix timestamp when the proof expires.

#### Example

Using text `Verifying until 1800000000 that I control the following Nostr public key: "npub1wf4pufsucer5va8g9p0rj5dnhvfeh6d8w0g6eayaep5dhps6rsgs43dgh9"`

```jsonc
{
  "kind": 0,
  "tags": [
    ["i", "x509:99e33b0c2d07e75fcd9df7e40e886646ff667e3aa6648e1a1160b036cf2b9320", "MEQCIBPBFh0cXoYYv87ncjfTs+RrGKkJ2u6Q9WsmLUjxPJ5MAiBfjY3VY78DyVK1LeOrHKdfXXUWni273B46lcKiagKsOg==", "MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEH/reUjCQlypniNHFvJaW0eBAek57CEKhDOYBQp+f0GPOkooe0xLtHHmn/2cGoxvbXAjpvFkjJLXm2wcXMyB1fg==", "1800000000"],
    // ...
  ],
  // ...
}
```

Example command to find the SHA-256 fingerprint of the certificate from a keystore: 

```bash
keytool -list -keystore example.keystore
```

Example of removing non-hexadecimal characters and lowercasing from the previous output:

```bash
echo -n "99:E3:3B:0C:2D:07:E7:5F:CD:9D:F7:E4:0E:88:66:46:FF:66:7E:3A:A6:64:8E:1A:11:60:B0:36:CF:2B:93:20" | tr -d -c '0-9A-Fa-f' | tr '[:upper:]' '[:lower:]'
```

Example commands to extract the private key and sign the message:

```bash
keytool -importkeystore -srckeystore example.keystore -destkeystore example.p12 -deststoretype pkcs12

openssl pkcs12 -in example.p12 -nocerts -noenc -out privatekey.pem

EXPIRY=$(date -d "+1 year" +%s)
echo -n "Verifying until ${EXPIRY} that I control the following Nostr public key: \"<npub>\"" | openssl dgst -sha256 -binary -sign privatekey.pem | openssl base64 -A
```

Example command to extract the public key:

```bash
openssl rsa -in privatekey.pem -outform der -pubout | base64
```

#### Client Verification

1. Extract `expiry` from tag[4]
2. Reconstruct message: `Verifying until <expiry> that I control the following Nostr public key: "<npub>"`
3. Verify signature (tag[2]) against public key (tag[3])
4. Check current time < expiry (warn if expired)
5. Optionally verify public key fingerprint matches tag[1]
