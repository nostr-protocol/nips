NIP-44
======

Encrypted Direct Message (Versioned)
------------------------------------

`optional` `author:paulmillr`

The NIP replaces NIP4, which is deficient with regards to algorithm choices, and introduces cryptography versioning. NIP4 is potentially vulnerable to [padding oracle attacks](https://en.wikipedia.org/wiki/Padding_oracle_attack) and uses keys which are not indistinguishable from random.

A special event with kind `44`, meaning "encrypted direct message". It is supposed to have the following attributes:

**`content`** MUST be equal to the base64-encoded, ALGORITHM encrypted string of anything a user wants to write, encrypted using a shared cipher generated by combining the recipient's public-key with the sender's private-key; this appended by the base64-encoded initialization vector as if it was a querystring parameter named "iv". The format is the following: `"content": "<encrypted_text>?iv=<initialization_vector>"`.

**`tags`** MUST contain an entry identifying the receiver of the message (such that relays may naturally forward this event to them), in the form `["p", "<pubkey, as a hex string>"]`.

**`tags`** MAY contain an entry identifying the previous message in a conversation or a message we are explicitly replying to (such that contextual, more organized conversations may happen), in the form `["e", "<event_id>"]`.

**Note**: By default in the [libsecp256k1](https://github.com/bitcoin-core/secp256k1) ECDH implementation, the secret is the SHA256 hash of the shared point (both X and Y coordinates). We are using this exact implementation. In NIP4, unhashed shared point was used.

## Versioning

Clients MUST throw a descriptive error if they receive NIP44 message, version of which they don't support.

Currently defined encryption algorithms:

- `0x00` - RESERVED
- `0x01` - ChaCha20 + sha256(ecdh)

## Security Warning

This standard does not go anywhere near what is considered the state-of-the-art in encrypted communication between peers, and it leaks metadata in the events, therefore it must not be used for anything you really need to keep secret, and only with relays that use `AUTH` to restrict who can fetch your `kind:4` events.

## Client Implementation Warning

Clients *should not* search and replace public key or note references from the `.content`. If processed like a regular text note (where `@npub...` is replaced with `#[0]` with a `["p", "..."]` tag) the tags are leaked and the mentioned user will receive the message in their inbox.

## Algorithm

```js
import {randomBytes} from '@noble/hashes/utils'
import {secp256k1} from '@noble/curves/secp256k1'
import {base64} from '@scure/base'
import {streamXOR as xchacha20_stream} from '@stablelib/xchacha20'
import {utf8Decoder, utf8Encoder} from './utils.ts'
import {sha256} from '@noble/hashes/sha256'

export function getConversationKey(privkeyA: string, pubkeyB: string) {
  const key = secp256k1.getSharedSecret(privkeyA, '02' + pubkeyB)
  return sha256(key.slice(1, 33))
}

export function encrypt(
  privkey: string,
  pubkey: string,
  text: string,
  ver = 1
): string {
  if (ver !== 1) throw new Error('NIP44: unknown encryption version')
  let key = getConversationKey(privkey, pubkey)
  let nonce = randomBytes(24)
  let plaintext = utf8Encoder.encode(text)
  let ciphertext = xchacha20_stream(key, nonce, plaintext, plaintext)
  let ctb64 = base64.encode(ciphertext)
  let nonceb64 = base64.encode(nonce)
  return JSON.stringify({ciphertext: ctb64, nonce: nonceb64, v: 1})
}

export function decrypt(privkey: string, pubkey: string, data: string): string {
  let dt = JSON.parse(data)
  if (dt.v !== 1) throw new Error('NIP44: unknown encryption version')
  let {ciphertext, nonce} = dt
  ciphertext = base64.decode(ciphertext)
  nonce = base64.decode(nonce)
  let key = getConversationKey(privkey, pubkey)
  let plaintext = xchacha20_stream(key, nonce, ciphertext, ciphertext)
  let text = utf8Decoder.decode(plaintext)
  return text
}
```
