# NIP-144

Service Authorization Protocol

`draft` `optional`

This NIP defines a protocol for authorizing third-party services to interact
with a user's Nostr data without access to their private key (`nsec`). It
establishes a shared symmetric encryption key between a user and a service,
enabling the service to encrypt and decrypt shared data while the user
retains full control over authorization, key rotation, and revocation.

## Motivation

Many Nostr-native applications require server-side services to perform
operations that involve sensitive data: decrypting payment credentials,
reading encrypted configuration, or processing confidential information on
behalf of a user. The straightforward approach — handing the user's private
key to the service — creates unacceptable security and trust risks:

- The service can sign **any** event as the user
- Key compromise at the service exposes every user who shared their key
- Users cannot selectively revoke access without changing their Nostr identity
- Users lose sovereignty over their own data and event history

This NIP provides a way for users to authorize services to:

1. Encrypt and decrypt shared data using a symmetric key without access to
   the user's private key
2. Operate autonomously for time-sensitive tasks while the user is offline
3. Be scoped to specific resources (e.g., a particular entity or dataset)
4. Be revoked at any time without the user changing their Nostr identity

The shared key grants **encryption/decryption capability only** — it does
not grant signing authority. The service cannot sign events as the user.

## Definitions

- **Principal**: The Nostr user granting authorization (e.g., a business
  operator, an account holder)
- **Service**: The server-side application requesting authorization (e.g., a
  booking engine, a payment processor)
- **Shared Key**: A 32-byte symmetric encryption key known to both principal
  and service

## Event Kinds

### Service Authorization (kind 31440)

An addressable event published by the **principal** to authorize a service.
Since it is addressable (kind 30000–39999), publishing a new event with the
same `d` tag replaces the previous authorization.

```json
{
  "kind": 31440,
  "pubkey": "<principal_pubkey>",
  "created_at": "<unix_timestamp>",
  "tags": [
    ["d", "<authorization_id>"],
    ["p", "<service_pubkey>"],
    ["a", "<kind>:<pubkey>:<d_tag>", "<relay_hint>"],
    ["kinds", "31923", "31924", "33003", "5"],
    ["relay", "<relay_url>"],
    ["relay", "<relay_url>"],
    ["expiration", "<unix_timestamp>"]
  ],
  "content": "<NIP-44 encrypted JSON>",
  "sig": "<signature>"
}
```

**Tags:**

| Tag          | Required      | Description                                                                                                                                                                                                                               |
| ------------ | ------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `d`          | yes           | Unique identifier for this authorization. SHOULD be unique per key version (see Key Versioning below).                                                                                                                                    |
| `p`          | yes           | Public key of the service being authorized.                                                                                                                                                                                               |
| `a`          | no (repeated) | Scope reference — an addressable event coordinate that this authorization pertains to. When present, the shared key and authorization apply only to data related to the referenced event. Omitting `a` creates an unscoped authorization. |
| `kinds`      | no            | Event kinds the service is authorized to create on behalf of the principal (see Kind Scope below). Values are stringified kind numbers.                                                                                                   |
| `relay`      | no (repeated) | Preferred relay URLs for communication.                                                                                                                                                                                                   |
| `expiration` | no            | Unix timestamp after which this authorization is no longer valid.                                                                                                                                                                         |

**Scope:**

The optional `a` tag binds the authorization to a specific addressable event.
For example, if the principal manages multiple entities (e.g., multiple
businesses), each entity's authorization can be scoped to that entity's
event. The service SHOULD only use the shared key for data related to the
referenced scope.

Multiple `a` tags MAY be included to authorize the service for multiple
scopes under a single shared key. Alternatively, the principal MAY publish
separate kind 31440 events (with different `d` tags) for each scope, each
with its own shared key.

**Kind Scope:**

The optional `kinds` tag declares which Nostr event kinds the service is
authorized to create using its own signing key on behalf of the principal.
This does not grant signing authority over the principal's key — the service
signs these events with its own key — but it declares the principal's intent
for what the service should publish within the authorization scope.

```json
["kinds", "31923", "31924", "33003", "5"]
```

Clients and verifiers SHOULD check that service-published events fall within
the declared kind scope. If the `kinds` tag is absent, no kind restriction
is implied (the authorization covers encryption/decryption only, not event
creation).

**Content:**

The `content` field is [NIP-44](https://github.com/nostr-protocol/nips/blob/master/44.md)
encrypted between the principal's private key and the service's public key.
Both parties can decrypt it using standard NIP-44 ECDH.

```json
{
  "shared_key": "<64-char hex-encoded 32-byte random key>",
  "name": "<human-readable service name>",
  "created_at": "<unix_timestamp>"
}
```

| Field        | Required | Description                                                                                                                                               |
| ------------ | -------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `shared_key` | yes      | Cryptographically random 32-byte key, hex-encoded. Used for all symmetric encryption between the principal and service within this authorization's scope. |
| `name`       | no       | Human-readable label for the service (e.g., "Acme Booking Service").                                                                                      |
| `created_at` | yes      | Timestamp of key generation. Used to determine key freshness during rotation.                                                                             |

### Service Authorization Acknowledgment (kind 31441)

An addressable event published by the **service** to confirm receipt of the
authorization and shared key. This event serves as the on-protocol proof
that the service has been authorized and holds the shared key — replacing
the need for off-protocol storage of authorization state.

```json
{
  "kind": 31441,
  "pubkey": "<service_pubkey>",
  "created_at": "<unix_timestamp>",
  "tags": [
    ["d", "<authorization_id>"],
    ["p", "<principal_pubkey>"],
    ["a", "31440:<principal_pubkey>:<authorization_id>", "<relay_hint>"]
  ],
  "content": "<NIP-44 encrypted JSON>",
  "sig": "<signature>"
}
```

**Tags:**

| Tag | Required | Description                                                     |
| --- | -------- | --------------------------------------------------------------- |
| `d` | yes      | Same authorization ID from the kind 31440 event.                |
| `p` | yes      | The principal's public key.                                     |
| `a` | yes      | Reference to the authorization event, with optional relay hint. |

**Content:**

The `content` field is [NIP-44](https://github.com/nostr-protocol/nips/blob/master/44.md)
encrypted between the service's private key and the principal's public key.

```json
{
  "status": "acknowledged",
  "shared_key_hash": "<hex-encoded SHA-256 of the shared_key>"
}
```

| Field             | Required | Description                                                                                       |
| ----------------- | -------- | ------------------------------------------------------------------------------------------------- |
| `status`          | yes      | `"acknowledged"` to confirm receipt.                                                              |
| `shared_key_hash` | yes      | SHA-256 hash of the shared key. Proves the service received the correct key without revealing it. |

Clients and services check for the existence of a valid kind 31441 event to
determine whether an authorization is active. The kind 31441 event is the
canonical record of authorization status on the protocol.

## Shared Key

### Generation

The principal generates the shared key client-side using a cryptographically
secure random number generator:

```
shared_key = CSPRNG(32 bytes)
```

The key MUST be generated on the principal's device. The service MUST NOT
generate or suggest a key.

### Transport

The shared key is transported inside the kind 31440 event's `content` field,
encrypted with [NIP-44](https://github.com/nostr-protocol/nips/blob/master/44.md)
between the principal and service public keys. This ensures:

- Only the principal and service can read the key
- The key is transported over Nostr relays without exposure
- No out-of-band channel is required

After publishing the kind 31440 event, the principal MAY notify the service
via an authenticated HTTP request
([NIP-98](https://github.com/nostr-protocol/nips/blob/master/98.md))
containing the event ID, so the service can immediately fetch and process
the authorization rather than waiting for relay subscription updates.

### Encryption Format

Data encrypted with the shared key uses the same encryption algorithm as
[NIP-44](https://github.com/nostr-protocol/nips/blob/master/44.md) version 2,
but with the shared key used directly as the `conversation_key` input:

```
nonce           = CSPRNG(32 bytes)
message_key     = HKDF-expand(sha256, prk=shared_key, info=nonce, length=76)
encryption_key  = message_key[0:32]
nonce_chacha    = message_key[32:44]
hmac_key        = message_key[44:76]

padded          = pad(plaintext)
ciphertext      = ChaCha20(key=encryption_key, nonce=nonce_chacha, data=padded)
mac             = HMAC-SHA256(key=hmac_key, message=nonce || ciphertext)

payload         = base64_encode(0x02 || nonce || ciphertext || mac)
```

This reuses NIP-44's proven encryption primitives. The only difference from
standard NIP-44 is the key source: instead of deriving the `conversation_key`
via ECDH, the pre-shared symmetric key is used directly.

Implementations SHOULD use existing NIP-44 libraries by providing the shared
key where the `conversation_key` would normally be supplied.

When encrypting event content with the shared key, the plaintext MUST be a
valid JSON string. The structure of the JSON is application-defined but
SHOULD follow a consistent schema documented by the service.

### Key Versioning

Each new shared key SHOULD be published with a unique `d` tag rather than
reusing the same `d` tag. This preserves old authorization events on relays,
allowing any party to look up the key that was active when a given event was
encrypted.

**Recommended `d` tag format:**

```
<service-name>-<principal_pubkey_prefix>-<unix_timestamp>
```

For example: `acme-booking-a1b2c3d4-1709251200`

When a new key is issued:

1. The principal generates a new shared key
2. The principal publishes a new kind 31440 event with a **new unique `d` tag**
3. The service detects the new event, decrypts the new key, and stores it
   alongside previous keys (a "key ring")
4. The service publishes a new kind 31441 acknowledgment for the new event
5. The service uses the newest key for encrypting new data
6. Old events remain decryptable via their key reference (see below)

This approach avoids the data loss problem of same-`d`-tag rotation, where
replacing the authorization event makes old encrypted data undecryptable if
the previous key was not cached.

Key versioning is RECOMMENDED over same-`d`-tag rotation in all cases.

### Key Reference on Encrypted Events

Every event whose content is encrypted with the shared key SHOULD include an
`a` tag referencing the authorization event that contains the key:

```json
["a", "31440:<principal_pubkey>:<d_tag>"]
```

This is a standard addressable event coordinate — the same format used by
all `a` tags in Nostr. It creates an explicit link between encrypted data
and the key needed to decrypt it. Benefits:

- The service can look up the correct key for any event, regardless of age
- Multiple key versions can coexist without ambiguity
- Provides a natural audit trail of which key was active when
- No custom tag name required — standard `a` tag semantics apply

Events MAY contain multiple `a` tags (e.g., scope references alongside the
key reference). Consumers distinguish the key reference by its `31440:`
kind prefix.

If no `a` tag with a `31440:` prefix is present, the service SHOULD fall
back to the currently active key for decryption.

### Revocation

The principal revokes authorization by either:

1. **Deleting the authorization event**: Publishing a kind 5 deletion event
   targeting the kind 31440 event
2. **Publishing an expired replacement**: Publishing a new kind 31440 event
   with the same `d` tag and an `expiration` tag set to a past timestamp

Upon detecting revocation, the service MUST:

- Delete all cached copies of the shared key
- Stop processing requests for the principal
- Publish a kind 5 deletion targeting its kind 31441 acknowledgment

## Security Considerations

1. **Key storage**: Services MUST store the shared key with the same care as
   any cryptographic secret. If the service is compromised, only the shared
   key is exposed — not the principal's private key. The principal can revoke
   and rotate without changing their Nostr identity.

2. **Key isolation**: Each principal-service relationship has its own shared
   key. Compromise of one shared key does not affect other principals or
   other services authorized by the same principal.

3. **No signing authority**: The shared key provides encryption/decryption
   capability only. The service cannot sign events as the principal. All
   service-published events are signed with the service's own key and include
   an authorization reference for verification.

4. **Forward secrecy**: Issuing a new key version provides forward secrecy
   for new data. Old data encrypted with a previous key remains accessible
   via the key ring and `a` tag reference. After suspected compromise, the
   principal SHOULD issue a new key version and the service SHOULD stop
   using the compromised key for new encryptions.

5. **Authorization verification**: Any party can verify a service's
   authorization by:
   1. Fetching the kind 31440 event referenced in the service's `a` tag
   2. Confirming the kind 31440 event is signed by the principal
   3. Confirming the `p` tag in the kind 31440 event matches the service's
      pubkey
   4. Checking the `expiration` (if present) has not passed
   5. Confirming no kind 5 deletion targets the authorization event

6. **Relay availability**: The authorization event must be available on relays
   for the protocol to function. Services SHOULD cache the shared key locally
   and SHOULD use multiple relays for redundancy. The authorization event is
   the source of truth; the local cache is for performance.

7. **Principal sovereignty**: At no point does the service hold the
   principal's private key. If the principal revokes access and leaves the
   service, their Nostr identity and any events they signed remain intact
   under their own key.

8. **Scope enforcement**: When an authorization includes `a` scope tags, the
   service SHOULD only use the shared key for data related to the referenced
   events. This is enforced by convention — the shared key itself is not
   technically limited, but using it outside the declared scope violates the
   authorization contract.

## Example Flow

```
Principal                          Service                  Relays
    |                                 |                       |
    |  1. Generate shared_key         |                       |
    |     (client-side CSPRNG)        |                       |
    |                                 |                       |
    |  2. Publish kind 31440 ---------------------------->  Store
    |     d: "svc-a1b2c3d4-1709251200"                        |
    |     content: NIP-44 encrypted   |                       |
    |     {shared_key, name, ...}     |                       |
    |     tags: [p, service_pubkey]   |                       |
    |           [a, scope_event]      |                       |
    |           [kinds, 31923, ...]   |                       |
    |                                 |                       |
    |  3. NIP-98 auth'd POST -------->|                       |
    |     {event_id: "..."}           |                       |
    |                                 |                       |
    |                                 |  4. Fetch 31440 ----->|
    |                                 |<---- Event data ------|
    |                                 |                       |
    |                                 |  5. Decrypt content   |
    |                                 |     Extract shared_key|
    |                                 |     Add to key ring   |
    |                                 |     Set as active key |
    |                                 |                       |
    |                                 |  6. Publish 31441 --->  Store
    |                                 |     {status,          |
    |                                 |      shared_key_hash} |
    |                                 |                       |
    |  7. Detect acknowledgment <--------------------------|
    |     Verify shared_key_hash      |                       |
    |     Authorization complete      |                       |
    |                                 |                       |
    |  ... time passes ...            |                       |
    |                                 |                       |
    |  8. Publish encrypted data ---------------------------->  Store
    |     content: shared_key         |                       |
    |     encrypted JSON              |                       |
    |     tags: [a, 31440:<pk>:<d>]   |                       |
    |                                 |                       |
    |                                 |  9. Fetch & decrypt   |
    |                                 |     Look up key via a |
    |                                 |     tag → key ring    |
    |                                 |                       |
    |  ... key versioning ...         |                       |
    |                                 |                       |
    |  10. Generate new shared_key    |                       |
    |                                 |                       |
    |  11. Publish NEW kind 31440 --------------------------->  Store
    |      d: "svc-a1b2c3d4-1712000000" (new unique d-tag)    |
    |      Old 31440 persists on relays                       |
    |                                 |                       |
    |                                 |  12. Add new key to   |
    |                                 |      key ring, set as |
    |                                 |      active key       |
    |                                 |                       |
    |  13. New encrypted data uses ---------------------------> Store
    |      new key + new a tag        |                       |
    |      Old data still uses old a  |                       |
    |      tag → old key in ring      |                       |
```

**Step 1–7**: Authorization setup. The principal generates a key with a
unique `d` tag, publishes the authorization with a `kinds` scope, and
the service acknowledges receipt and adds the key to its key ring.

**Step 8–9**: Ongoing usage. Events encrypted with the shared key include an
`a` tag referencing the authorization event (`31440:` prefix). The service
resolves this `a` tag to look up the correct key from its key ring.

**Step 10–13**: Key versioning. A new key gets a new unique `d` tag. The old
authorization event persists on relays. Old events remain decryptable via
their `a` tag pointing to the old authorization. New events use the new key.
