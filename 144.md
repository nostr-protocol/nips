NIP-144
=======

Service Authorization Protocol

`draft` `optional`

This NIP defines a protocol for authorizing third-party services to interact
with a user's Nostr data without access to their private key (`nsec`). It
establishes a shared symmetric encryption key between a user and a service,
enabling the service to encrypt and decrypt shared data while the user
retains full control over authorization, key rotation, and revocation.

## Motivation

Many Nostr-native applications require server-side services to perform
operations that involve sensitive data: decrypting payment credentials,
reading encrypted configuration, or processing confidential information on
behalf of a user. The straightforward approach — handing the user's private
key to the service — creates unacceptable security and trust risks:

- The service can sign **any** event as the user
- Key compromise at the service exposes every user who shared their key
- Users cannot selectively revoke access without changing their Nostr identity
- Users lose sovereignty over their own data and event history

This NIP provides a way for users to authorize services to:

1. Encrypt and decrypt shared data using a symmetric key without access to
   the user's private key
2. Operate autonomously for time-sensitive tasks while the user is offline
3. Be scoped to specific resources (e.g., a particular entity or dataset)
4. Be revoked at any time without the user changing their Nostr identity

The shared key grants **encryption/decryption capability only** — it does
not grant signing authority. The service cannot sign events as the user.

## Definitions

- **Principal**: The Nostr user granting authorization (e.g., a business
  operator, an account holder)
- **Service**: The server-side application requesting authorization (e.g., a
  booking engine, a payment processor)
- **Shared Key**: A 32-byte symmetric encryption key known to both principal
  and service

## Event Kinds

### Service Authorization (kind 31440)

An addressable event published by the **principal** to authorize a service.
Since it is addressable (kind 30000–39999), publishing a new event with the
same `d` tag replaces the previous authorization.

```json
{
  "kind": 31440,
  "pubkey": "<principal_pubkey>",
  "created_at": "<unix_timestamp>",
  "tags": [
    ["d", "<authorization_id>"],
    ["p", "<service_pubkey>"],
    ["a", "<kind>:<pubkey>:<d_tag>", "<relay_hint>"],
    ["relay", "<relay_url>"],
    ["relay", "<relay_url>"],
    ["expiration", "<unix_timestamp>"]
  ],
  "content": "<NIP-44 encrypted JSON>",
  "sig": "<signature>"
}
```

**Tags:**

| Tag | Required | Description |
|-----|----------|-------------|
| `d` | yes | Unique identifier for this authorization. Distinct per service or per scope if the principal creates multiple authorizations. |
| `p` | yes | Public key of the service being authorized. |
| `a` | no (repeated) | Scope reference — an addressable event coordinate that this authorization pertains to. When present, the shared key and authorization apply only to data related to the referenced event. Omitting `a` creates an unscoped authorization. |
| `relay` | no (repeated) | Preferred relay URLs for communication. |
| `expiration` | no | Unix timestamp after which this authorization is no longer valid. |

**Scope:**

The optional `a` tag binds the authorization to a specific addressable event.
For example, if the principal manages multiple entities (e.g., multiple
businesses), each entity's authorization can be scoped to that entity's
event. The service SHOULD only use the shared key for data related to the
referenced scope.

Multiple `a` tags MAY be included to authorize the service for multiple
scopes under a single shared key. Alternatively, the principal MAY publish
separate kind 31440 events (with different `d` tags) for each scope, each
with its own shared key.

**Content:**

The `content` field is [NIP-44](44.md)
encrypted between the principal's private key and the service's public key.
Both parties can decrypt it using standard NIP-44 ECDH.

```json
{
  "shared_key": "<64-char hex-encoded 32-byte random key>",
  "name": "<human-readable service name>",
  "created_at": "<unix_timestamp>"
}
```

| Field | Required | Description |
|-------|----------|-------------|
| `shared_key` | yes | Cryptographically random 32-byte key, hex-encoded. Used for all symmetric encryption between the principal and service within this authorization's scope. |
| `name` | no | Human-readable label for the service (e.g., "Acme Booking Service"). |
| `created_at` | yes | Timestamp of key generation. Used to determine key freshness during rotation. |

### Service Authorization Acknowledgment (kind 31441)

An addressable event published by the **service** to confirm receipt of the
authorization and shared key. This event serves as the on-protocol proof
that the service has been authorized and holds the shared key — replacing
the need for off-protocol storage of authorization state.

```json
{
  "kind": 31441,
  "pubkey": "<service_pubkey>",
  "created_at": "<unix_timestamp>",
  "tags": [
    ["d", "<authorization_id>"],
    ["p", "<principal_pubkey>"],
    ["a", "31440:<principal_pubkey>:<authorization_id>", "<relay_hint>"]
  ],
  "content": "<NIP-44 encrypted JSON>",
  "sig": "<signature>"
}
```

**Tags:**

| Tag | Required | Description |
|-----|----------|-------------|
| `d` | yes | Same authorization ID from the kind 31440 event. |
| `p` | yes | The principal's public key. |
| `a` | yes | Reference to the authorization event, with optional relay hint. |

**Content:**

The `content` field is [NIP-44](44.md)
encrypted between the service's private key and the principal's public key.

```json
{
  "status": "acknowledged",
  "shared_key_hash": "<hex-encoded SHA-256 of the shared_key>"
}
```

| Field | Required | Description |
|-------|----------|-------------|
| `status` | yes | `"acknowledged"` to confirm receipt. |
| `shared_key_hash` | yes | SHA-256 hash of the shared key. Proves the service received the correct key without revealing it. |

Clients and services check for the existence of a valid kind 31441 event to
determine whether an authorization is active. The kind 31441 event is the
canonical record of authorization status on the protocol.

## Shared Key

### Generation

The principal generates the shared key client-side using a cryptographically
secure random number generator:

```
shared_key = CSPRNG(32 bytes)
```

The key MUST be generated on the principal's device. The service MUST NOT
generate or suggest a key.

### Transport

The shared key is transported inside the kind 31440 event's `content` field,
encrypted with [NIP-44](44.md)
between the principal and service public keys. This ensures:

- Only the principal and service can read the key
- The key is transported over Nostr relays without exposure
- No out-of-band channel is required

After publishing the kind 31440 event, the principal MAY notify the service
via an authenticated HTTP request
([NIP-98](98.md))
containing the event ID, so the service can immediately fetch and process
the authorization rather than waiting for relay subscription updates.

### Encryption Format

Data encrypted with the shared key uses the same encryption algorithm as
[NIP-44](44.md) version 2,
but with the shared key used directly as the `conversation_key` input:

```
nonce           = CSPRNG(32 bytes)
message_key     = HKDF-expand(sha256, prk=shared_key, info=nonce, length=76)
encryption_key  = message_key[0:32]
nonce_chacha    = message_key[32:44]
hmac_key        = message_key[44:76]

padded          = pad(plaintext)
ciphertext      = ChaCha20(key=encryption_key, nonce=nonce_chacha, data=padded)
mac             = HMAC-SHA256(key=hmac_key, message=nonce || ciphertext)

payload         = base64_encode(0x02 || nonce || ciphertext || mac)
```

This reuses NIP-44's proven encryption primitives. The only difference from
standard NIP-44 is the key source: instead of deriving the `conversation_key`
via ECDH, the pre-shared symmetric key is used directly.

Implementations SHOULD use existing NIP-44 libraries by providing the shared
key where the `conversation_key` would normally be supplied.

When encrypting event content with the shared key, the plaintext MUST be a
valid JSON string. The structure of the JSON is application-defined but
SHOULD follow a consistent schema documented by the service.

### Rotation

To rotate the shared key:

1. The principal generates a new shared key
2. The principal publishes a new kind 31440 event with the same `d` tag
   (replacing the previous authorization, since the event is addressable)
3. The service detects the updated event, decrypts the new key
4. The service publishes a new kind 31441 acknowledgment
5. Data encrypted with the old key SHOULD be re-encrypted with the new key
   by the principal

Rotation is RECOMMENDED:

- Periodically (e.g., every 90 days)
- After suspected compromise of the service
- When revoking and re-authorizing a service

### Revocation

The principal revokes authorization by either:

1. **Deleting the authorization event**: Publishing a kind 5 deletion event
   targeting the kind 31440 event
2. **Publishing an expired replacement**: Publishing a new kind 31440 event
   with the same `d` tag and an `expiration` tag set to a past timestamp

Upon detecting revocation, the service MUST:

- Delete all cached copies of the shared key
- Stop processing requests for the principal
- Publish a kind 5 deletion targeting its kind 31441 acknowledgment

## Security Considerations

1. **Key storage**: Services MUST store the shared key with the same care as
   any cryptographic secret. If the service is compromised, only the shared
   key is exposed — not the principal's private key. The principal can revoke
   and rotate without changing their Nostr identity.

2. **Key isolation**: Each principal-service relationship has its own shared
   key. Compromise of one shared key does not affect other principals or
   other services authorized by the same principal.

3. **No signing authority**: The shared key provides encryption/decryption
   capability only. The service cannot sign events as the principal. All
   service-published events are signed with the service's own key and include
   an authorization reference for verification.

4. **Forward secrecy**: Rotating the shared key provides forward secrecy for
   new data. Old data encrypted with a previous key remains accessible only
   to parties that had the old key.

5. **Authorization verification**: Any party can verify a service's
   authorization by:
   1. Fetching the kind 31440 event referenced in the service's `a` tag
   2. Confirming the kind 31440 event is signed by the principal
   3. Confirming the `p` tag in the kind 31440 event matches the service's
      pubkey
   4. Checking the `expiration` (if present) has not passed
   5. Confirming no kind 5 deletion targets the authorization event

6. **Relay availability**: The authorization event must be available on relays
   for the protocol to function. Services SHOULD cache the shared key locally
   and SHOULD use multiple relays for redundancy. The authorization event is
   the source of truth; the local cache is for performance.

7. **Principal sovereignty**: At no point does the service hold the
   principal's private key. If the principal revokes access and leaves the
   service, their Nostr identity and any events they signed remain intact
   under their own key.

8. **Scope enforcement**: When an authorization includes `a` scope tags, the
   service SHOULD only use the shared key for data related to the referenced
   events. This is enforced by convention — the shared key itself is not
   technically limited, but using it outside the declared scope violates the
   authorization contract.

## Example Flow

```
Principal                          Service                  Relays
    |                                 |                       |
    |  1. Generate shared_key         |                       |
    |     (client-side CSPRNG)        |                       |
    |                                 |                       |
    |  2. Publish kind 31440 ---------------------------->  Store
    |     content: NIP-44 encrypted   |                       |
    |     {shared_key, name, ...}     |                       |
    |     tags: [p, service_pubkey]   |                       |
    |           [a, scope_event]      |                       |
    |                                 |                       |
    |  3. NIP-98 auth'd POST -------->|                       |
    |     {event_id: "..."}           |                       |
    |                                 |                       |
    |                                 |  4. Fetch 31440 ----->|
    |                                 |<---- Event data ------|
    |                                 |                       |
    |                                 |  5. Decrypt content   |
    |                                 |     Extract shared_key|
    |                                 |     Cache locally     |
    |                                 |                       |
    |                                 |  6. Publish 31441 --->  Store
    |                                 |     {status,          |
    |                                 |      shared_key_hash} |
    |                                 |                       |
    |  7. Detect acknowledgment <--------------------------|
    |     Verify shared_key_hash      |                       |
    |     Authorization complete      |                       |
    |                                 |                       |
    |  ... time passes ...            |                       |
    |                                 |                       |
    |  8. Publish encrypted data ---------------------------->  Store
    |     (e.g., payment config)      |                       |
    |     content: shared_key         |                       |
    |     encrypted JSON              |                       |
    |                                 |                       |
    |                                 |  9. Fetch & decrypt   |
    |                                 |     using shared_key  |
    |                                 |                       |
```

**Step 1–7**: One-time authorization setup. The principal generates the key,
publishes the authorization, and the service acknowledges receipt.

**Step 8–9**: Ongoing usage. The principal publishes events with content
encrypted using the shared key. The service fetches and decrypts them as
needed using the same key. The service may also publish events with
shared-key-encrypted content that the principal can decrypt.
