NIP-C1
======

Cryptographic Identity Proofs
-----------------------------

`draft` `optional`

## Abstract

This NIP defines a standard for linking cryptographic identities to Nostr profiles. It allows users to prove they control a specific public key, enabling verification against external sources such as signed software artifacts.

## Supported Key Types

| Kind  | Type  | Description                                           |
|-------|-------|-------------------------------------------------------|
| 30509 | SPKI  | SubjectPublicKeyInfo (SPKI) extracted from code-signing certificates (e.g., Android APK signing) |

Future versions may add support for additional types such as OpenPGP.

## Event Format

A cryptographic identity proof is published as a parameterized replaceable event:

```jsonc
{
  "kind": 30509,
  "pubkey": "<nostr-pubkey-hex>",
  "created_at": <timestamp>,
  "tags": [
    ["d", "<spkifp>"],
    ["signature", "<signature-base64>"],
    ["expiry", "<unix-timestamp>"]
  ],
  "content": ""
}
```

### Tag Definitions

| Tag         | Description                                        |
|-------------|----------------------------------------------------|
| `d`         | Identity fingerprint (SPKIFP), 64 lowercase hex    |
| `signature` | Signature in base64 (RFC 4648, with padding, no whitespace) |
| `expiry`    | Expiry timestamp as Unix seconds (base-10 digits); MUST be greater than `created_at` |
| `revoked`   | If present, this identity proof has been revoked (optional reason as value) |

## Identity Fingerprint

The identity fingerprint is the SHA-256 hash of the DER-encoded SubjectPublicKeyInfo (SPKI), lowercase hex.

Using SPKIFP rather than certificate fingerprint allows:
- Multiple certificates to share the same identity (re-issuance, different CAs)
- Comparison to certificates from external sources (APKs, keystores)

## Proof Message

The signature is computed over the following message:

```
Verifying at <created_at> until <expiry> that I control the following Nostr public key: <pubkey>
```

Where:
- `<created_at>` is the Unix timestamp (seconds), base-10 ASCII digits, and MUST equal the event's `created_at` field
- `<expiry>` is the Unix timestamp (seconds), base-10 ASCII digits, and MUST equal the `expiry` tag
- `<pubkey>` is the 64-character lowercase hex Nostr public key, and MUST equal the event `pubkey`

The signed message MUST be encoded as UTF-8 bytes exactly as shown (no trailing newline). Implementations MUST NOT add or remove whitespace.

## Signature Algorithm

Verifiers determine the algorithm from the SPKI key type:

| SPKI Key Type | Verification                                       |
|---------------|----------------------------------------------------|
| RSA           | PKCS#1 v1.5 with SHA-256                           |
| ECDSA         | ECDSA over SHA-256, ASN.1 DER signature            |

Signatures are computed over the SHA-256 hash of the proof message.

> **Note:** These algorithms cover the vast majority of Android APK signing certificates. Future revisions may add an `algorithm` tag if additional schemes (e.g., RSA-PSS, Ed25519) see significant adoption.

## Verification Requirements

Verifiers MUST:
1. Compute SHA-256 of the SPKI and confirm it matches the `d` tag
2. Determine key type from SPKI and verify signature accordingly
3. Confirm `expiry > created_at` and current time < `expiry`
4. Query all relays in the user's relay list for events with the same `d` tag and `pubkey`, and confirm no version has a `revoked` tag

## Example

```jsonc
{
  "kind": 30509,
  "id": "b1676e8865e1f82b7ebeac124bd5c6dfc468567bf38bc4e75b5b1e7c8dd01540",
  "pubkey": "78ce6faa72264387284e647ba6938995735ec8c7d5c5a65737e55130f026307d",
  "created_at": 1768751639,
  "tags": [
    [
      "d",
      "0b691b7d30a4e9c01b18d0d2dd51e395e07a4a0f41e61bbdb8feaa5fe05297c2"
    ],
    [
      "signature",
      "MEYCIQDhI/ZXNY+8Jhym23cUIaAv6jL2HsNPoF5t9HnmPyC4igIhAK8yhi2JD+1Y0U1XRyFOoHdH7SB5xolTWSKnNbpgUAZd"
    ],
    [
      "expiry",
      "1800287639"
    ]
  ],
  "content": "",
  "sig": "c01f42999391055abd9bfd29539f556d3a09e8d660dec116db821415e1c3af4133a1aa41a142fcfe27cffcdef1aeb087cf6b785fe89c8d23b68638241d568eaf"
}
```

The signed message for this example is:

```
Verifying at 1768751639 until 1800287639 that I control the following Nostr public key: 78ce6faa72264387284e647ba6938995735ec8c7d5c5a65737e55130f026307d
```

## Creating a Proof

Export private key from Java keystore:

```bash
keytool -importkeystore -srckeystore example.keystore -destkeystore example.p12 -deststoretype pkcs12
openssl pkcs12 -in example.p12 -nocerts -noenc -out privatekey.pem
```

Compute SPKIFP (for `d` tag):

```bash
openssl pkey -in privatekey.pem -pubout -outform der | sha256sum | cut -d' ' -f1
```

Sign the proof message:

```bash
CREATED_AT=$(date +%s)
EXPIRY=$(date -d "+1 year" +%s)
PUBKEY="78ce6faa72264387284e647ba6938995735ec8c7d5c5a65737e55130f026307d"
echo -n "Verifying at ${CREATED_AT} until ${EXPIRY} that I control the following Nostr public key: ${PUBKEY}" \
  | openssl dgst -sha256 -sign privatekey.pem | openssl base64 -A
```

## Verifying Against an APK

Extract SPKIFP from APK (must match `d` tag):

```bash
apksigner verify --print-certs -v app.apk 2>&1 | grep -m1 'public key SHA-256' | cut -d: -f2 | tr -d ' '
```

Extract public key for signature verification:

```bash
apksigner verify --print-certs-pem app.apk 2>&1 \
  | sed -n '/BEGIN CERTIFICATE/,/END CERTIFICATE/p' \
  | openssl x509 -pubkey -noout > pubkey.pem
```

Verify signature:

```bash
echo -n "Verifying at ${CREATED_AT} until ${EXPIRY} that I control the following Nostr public key: ${PUBKEY}" \
  | openssl dgst -sha256 -verify pubkey.pem -signature <(echo "${SIGNATURE}" | base64 -d)
```

## Revocation

To revoke, publish a new event with the `revoked` tag (reason optional but recommended):

```jsonc
["d", "<spkifp>"],
["revoked", "key-compromised"]  // or: key-retired, superseded
```

Standard replaceable-event semantics apply, except: **`key-compromised` is permanent**. Relays MUST reject updates after a `key-compromised` revocation; clients MUST ignore them.

## Security Considerations

1. **Signature verification required** — Clients MUST verify signatures before trusting identity claims.
2. **SPKIFP binding** — The public key hash MUST match the `d` tag.
3. **Replay prevention** — Both `created_at` and `expiry` are bound into the signed message.
4. **Revocation checking** — Clients MUST check all relays in the user's relay list for revocation before trusting a proof.
