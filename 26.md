
NIP-30
======

NostrAuth
---------

`draft` `optional` `author:saranshisatgit`

The current approach for signed events is good. Proposing a alternative method for generating event with a `UIN` (User Identification Number). User Identification Number are generated out of existing pubkeys. These UIN can be stored in public database somewhere like namecoin, spacechains, HNS where users can claim unique names by paying fees associated to the network. These UIN can be fetched by the client and relays on demand and could be useful in determinig certain attributes say providing specific service to the user or a role or permissions and build reputations.

This makes identification easier and stop spamming since its harder to acquire new identities , user preference can be thus stored retrieved whenever desired, user can signal to remove the UIN by revoking data publically.

My motivation is to make the user namespace and identification easier across clients and relays so that we can build things like blogging, relationships. This would be a good starting point for the reputation web of trust style unique identifiers. Mike hearn points out in one post[4]: For anonymous users to take part, a cost on establishing an identity must be imposed. We can do this by requiring users to present a proof that they gave away some coins to miner fees. The proof is standalone and can be checked by anyone who has a copy of the block headers. The hash of that proof becomes the pseudonym, it can be checked against Spamhaus style DNS blacklists to discover past behaviour that has been associated with that nym and optionally blocked.

Generating UIN could be done as shown below, since keypair is already generated we can use the `NIP-06`  or as client needs. 


**Generate**

```
nostrAuth.generateUIN()
```

The follwing function that will return a UIN from the public key;

```
function(pubkey) {
  let pubkeyBuffer;
  if (!Buffer.isBuffer(pubkey)) {
    pubkeyBuffer = Buffer.from(pubkey, 'hex');
  } else {
    pubkeyBuffer = pubkey;
  }

  // sha256 hash the pubkey
  const pubHash = crypto.createHash('sha256').update(pubkeyBuffer).digest();

  // get the ripemd160 hash of the pubkey
  const pubRipe = crypto.createHash('rmd160').update(pubHash).digest();

  // add the version
  const pubPrefixed = Buffer.concat([Buffer.from('0f02', 'hex');, pubRipe]);

  // two rounds of hashing to generate the checksum
  const hash1 = crypto.createHash('sha256').update(pubPrefixed).digest();
  const checksumTotal = crypto.createHash('sha256').update(hash1).digest();

  // slice the hash to arrive at the checksum
  const checksum = checksumTotal.slice(0, 4);

  // add the checksum to the ripemd160 pubkey
  const pubWithChecksum = Buffer.concat([pubPrefixed, checksum]);

  // encode into base58 to get SIN
  return bs58.encode(pubWithChecksum);
};
```

This will produce  

```
{
  uin: 'TfGeAbsDxTKB9VEHX9X6EpMXbEB25Jh27Nj'
}
```

Types of UIN
----

Type 1 is validated or some fees paid on to Bitcoin. ie Persistent UIN.

Type 2 is ephemeral and does not need any fees paid.


Paying for UIN
----

`pubkey;`
`BH = BlockHeight`
`Create and Sign Transaction`

  1. must include Hash160(MPK) OP_TRUE anyone-can-spend output with value >= 0.001BTC
  2. nlocktime = BH + 144 blocks
  3. no more than 1000 bytes in size

`Create, sign and broadcast transaction T1`
  1. must include OP_RETURN serialized(T2) output as last txout

Validation
----

The validation of UIN 

```
B1 = block w/ T1
B2 = block w/ T2
Verify B2 height - 144 >= B1 height.
Verify announced T2 is valid
Verify mined T2 spends same inputs as announced T2 (not equal to account for Transaction Malleability)
Fail and waste sacrifice if not.
```


Example
----
Example code

```json

{
  "pubkey": "b0635d6a9851d3aed0cd6c495b282167acf761729078d975fc341b22650b07b9",
  "kind": 0,
  "x-UIN":"derive.pubkey"
  "uin":true
  "s":persitent
  "follow":"provide link to the UIN Public Resource like 'www.example.com/UIN'"
  "name": "Alice"
  ...
}
```



Once the event is published with the `uin` as true the relay should lookup for the UIN, these UIN can be ephemeral or persitent as provided in the event.
The relay verifies that the signature is valid and that it matches the identity (the public key). It then computes the UIN from the public key, and sees whether that UIN has access to the requested resource. 

Motivation
----

The use cases are as follows 

1. User recognition 
2. Reputation 

Some cases also from references are

1. Identity Verification, Inc. digitally signs a SIN as passing their Not A Criminal/Level-1 check.
2. Big Auction Provider, Inc. digitally signs a SIN as having a certain reputation score, on their website.
3. Decentralized market users digitally sign one another's SINs, building a decentralized reputation


References are 

[1](https://en.bitcoin.it/wiki/Identity_protocol_v1)
[2](https://github.com/bitpay/bitauth)
[3](https://en.bitcoin.it/wiki/Fidelity_bonds#Announce.2FCommit_Sacrifices)
[4](https://bitcointalk.org/index.php?topic=140711.0)
