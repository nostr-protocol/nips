
NIP-30
======

NostrAuth
---------

`draft` `optional` `author:saranshisatgit`

The current approach for signed events is good. Proposing a new signed event with a `UIN` (User Identification Number). These UIN 
can be stored in public database somewhere like namecoin, spacechains, HNS where users can claim unique names. These UIN can be fetched by the client and relays on demand and could be useful in determinig certain attributes say providing specific service to the user or a role or permissions.

This makes identification easier , user preference can be thus stored retrieved whenever desired, user can signal to remove the UIN by revoking data publically.

My motivation is to make the user namespace and identification easier across clients and relays so that we can build things like blogging, relationships. This would be a good starting point for the reputation.

Generating UIN could be done like this, since keypair is already generated we can use the `NIP-06`  or as client needs.

**Generate**

```
nostrAuth.generateUIN()
```

The follwing function that will return a UIN from the public key;

```
function(pubkey) {
  let pubkeyBuffer;
  if (!Buffer.isBuffer(pubkey)) {
    pubkeyBuffer = Buffer.from(pubkey, 'hex');
  } else {
    pubkeyBuffer = pubkey;
  }

  // sha256 hash the pubkey
  const pubHash = crypto.createHash('sha256').update(pubkeyBuffer).digest();

  // get the ripemd160 hash of the pubkey
  const pubRipe = crypto.createHash('rmd160').update(pubHash).digest();

  // add the version
  const pubPrefixed = Buffer.concat([Buffer.from('0f02', 'hex');, pubRipe]);

  // two rounds of hashing to generate the checksum
  const hash1 = crypto.createHash('sha256').update(pubPrefixed).digest();
  const checksumTotal = crypto.createHash('sha256').update(hash1).digest();

  // slice the hash to arrive at the checksum
  const checksum = checksumTotal.slice(0, 4);

  // add the checksum to the ripemd160 pubkey
  const pubWithChecksum = Buffer.concat([pubPrefixed, checksum]);

  // encode into base58 to get SIN
  return bs58.encode(pubWithChecksum);
};
```

This will produce  

```
{
  uin: 'TfGeAbsDxTKB9VEHX9X6EpMXbEB25Jh27Nj'
}
```

If a user choose to generate UIN and does not want to register the UIN publically , then we can derive the UIN from PublicKey also as we demonstrated.


Example
----
Example code

```json

{
  "pubkey": "b0635d6a9851d3aed0cd6c495b282167acf761729078d975fc341b22650b07b9",
  "kind": 0,
  "x-UIN":"derive.pubkey"
  "uin":true
  "s":persitent
  "follow":"provide link to the UIN Public Resource like 'www.example.com/UIN'"
  "name": "Alice"
  ...
}
```

Once the event is published with the `uin` as true the relay should lookup for the UIN, these UIN can be ephemeral or persitent as provided in the event.
The relay verifies that the signature is valid and that it matches the identity (the public key). It then computes the UIN from the public key, and sees whether that UIN has access to the requested resource. 

Motivation
----

The use cases are as follows 

1. User recognition 
2. Reputation 

Some cases from the https://en.bitcoin.it/wiki/Identity_protocol_v1

1. Identity Verification, Inc. digitally signs a SIN as passing their Not A Criminal/Level-1 check.
2. Big Auction Provider, Inc. digitally signs a SIN as having a certain reputation score, on their website.
3. Decentralized market users digitally sign one another's SINs, building a decentralized reputation

