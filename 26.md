
NIP-26
======

NostrAuth
---------

`draft` `optional` `author:saranshisatgit`

The current approach for signed events is good but problematic on user side. Proposing a signed event with a `UIN` (User Identification Number). These UIN 
can be stored in public database somewhere like namecoin, spacechains, where users can claim unique names. These UIN can be fetched by the client and relays on demand and could be useful
in determinng certain attributes say providing specific service to the user or a role or permissions.

This makes identification easier , user preference can be thus stored retrieved whenever desired, user can signal to remove the UIN by revoking data publically.

My motivation is to make the user namespace and identification easier across clients and relays so that we can build things like blogging, relationships. This would be a good starting point for the reputation.

Generating UIN could be done like this, since keypair is already generated we can use the `NIP-06`  or as client needs.
**Generate**

```
nostrAuth.generateUIN()
```

This will produce  

```
{
  created: 1661671608,
  priv: '5e7d9dde9c2df88152c7e7a7791d416079e6d72d8de48cb6688e5f00b88b1077',
  pub: '066185612bc5b79079ffa8acc86bbd26a24ea811161740bd70e7f39e400a9d06',
  uin: 'TfGeAbsDxTKB9VEHX9X6EpMXbEB25Jh27Nj'
}
```

If a user choose to generate UIN and does not want to register the UIN publically , then we can derive the UIN from PublicKey also.


Example
----
Example code

```json

{
  "pubkey": "b0635d6a9851d3aed0cd6c495b282167acf761729078d975fc341b22650b07b9",
  "kind": 0,
  "x-identity":"nostrAuth.getPublicKeyfromPrivateKey"
  "uin":true
  "s":persitent
  ...
}
```

Once the event is published with the `uin` as true the relay should lookup for the UIN, these UIN can be ephemeral or persitent as provided in the event.
The relay verifies that the signature is valid and that it matches the identity (the public key). It then computes the UIN from the public key, and sees whether that UIN has access to the requested resource. 

