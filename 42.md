NIP-42
======

Authentication of clients to relays
-----------------------------------

`draft` `optional` `author:Semisol` `author:fiatjaf` `author:arthurfranca`

This is a `client` to `relay` authentication procedure which is
fast and easy to implement because it's non-interactive.

Authentication happens on connection start, not
requiring message exchange between `client` and `relay`.

## Motivation

A relay may want to require clients to authenticate to access restricted resources. For example,

- A relay may request payment or other forms of whitelisting to publish events.
It may choose to accept events with any pubkey value as long as they are published from an authenticated user;
- A relay may limit access to `kind: 4` DMs to only the parties involved in the chat exchange,
and for that it may require authentication before clients can query for that kind.
- A relay may limit subscriptions of any kind to paying users or users whitelisted through any other means,
and require authentication.

## How to Authenticate

The `client` must generate a `kind: 22242` ephemeral event with the current time as `created_at`
and the relay url as a `relay` tag.
Then it has to stringify the JSON event and [percent-encode](https://www.rfc-editor.org/rfc/rfc3986#page-12) it.
The resulting string is used as `authorization` query param when connecting to the relay.

### Javascript Example

```js
  const relayUrl = 'wss://relay.example.com'
  // add id and signature as usual
  const jsonEvent = generateNostrEvent({
    pubkey: "...",
    created_at: Math.floor(Date.now() / 1000),
    kind: 22242,
    tags: [['relay', relayUrl]],
    content: ""
  })
  const auth = window.encodeURIComponent(JSON.stringify(jsonEvent))
  const ws = new WebSocket(`${relayUrl}?authorization=${auth}`)
  ws.addEventListener('open', () => console.log('auth accepted'))
  ws.addEventListener('close', () => console.log('disconnected') )
```

## Relay Handling

`Relays` that require users to authenticate before performing atleast one action, must authenticate user on connection request.
The authorization query param must be decoded and validated. A valid event must:
- be of `kind` `22242`;
- have `created_at` within a small time window relative to the current date (e.g. 60 seconds);
- have the `relay` tag url value with the same domain name as the relay.

If the event is valid, its `pubkey` identifies the authenticated user.

The `relay` may end the socket right away if the user is not authorized to access the `relay`.

The `relay` should send a `NOTICE` or `OK` message (as per [NIP-20](20.md)) with a standard prefix `"restricted: "` (readable both by humans and machines)
when blocking authenticated user from accessing some resources.

For example, if an already authenticated user A requests DMs not sent by him and meant to be read only by user B,
relay should send a `NOTICE` like this one:

```
["NOTICE", "restricted: not authorized to access this user's DMs, please login with NIP-42"]
```

## Security Measures

The used protocol must be `wss` (WebSocket Secure).

The authorization event `id` should be stored by the `relay` for the same above mentioned time window so that
if the same event `id` is used twice, the `relay` should reject the connection immediately and
should also disconnect the user that first used the event to authenticate.
In this case the `relay` may send a `NOTICE` message with `"restricted: "` prefix informing
the first user before disconnecting him, for example:

```
["NOTICE", "restricted: your client is misbehaving, authorization event can't be reused."]
```

## Backward Compatibility

`Relays` may wish to support the legacy flow (it was in effect from 16/jan/2023 to 1/jun/2023) if the `authorization` query param is absent. They should send to connecting `clients`, at any moment, an `AUTH` message containing a `challenge`, as follows:

```
["AUTH", <challenge-string>]
```

`Clients` may then reply with an `AUTH` message containg a `kind` `22242` event, similar to the above mentioned one, **with** the same challenge as a tag, for example:

```
["AUTH", { "kind": 22242, ..., "tags": [["relay", "wss://relay.example.com/"], ["challenge", "challengestringhere"]] }]
```

`Relays` should validate the event as mentioned above, additionally checking if the `challenge` match the previously sent one.
