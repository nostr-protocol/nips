NIP-59
======

Lightning Zaps v2
-----------------

`draft` `optional` `author:ok300`


We propose a different way to implement Zaps than described in NIP-57.


## Definitions

> Zap: a way to make LN payments on nostr that allows paid invoices to be tallied publicly and associated with the Sender and Recipient pubkeys

> Sender: A nostr account who wishes to send a Zap. No special wallet integrations are necessary.

> Recipient: A nostr account who can receive Zaps on posted kind-1 notes or directly on his or her profile. A one-time pairing with a Zapper is needed to receive Zaps.

> Pairing: the state when a Client and a Zapper point to each other using profile metadata:
> - the Zapper's profile has the Client pubkey in its `nip59c` field
> - the Client's profile has the Zapper pubkey in its `nip59z` field

> Zapper: A service that combines an LN wallet and a nostr client.


## Workflow

- Sender
  - [1] creates a `ZapRequest` nostr event
  - [4] if `ZapInvoice` matches `ZapRequest`, shows LN Invoice to user
- Recipient Zapper
  - [2] if the `ZapRequest` is intended for its paired Client, continues
  - [3] creates a LN invoice and wraps it in a `ZapInvoice` nostr event
  - [5] monitors invoice, when paid it posts a `ZapReceipt` nostr event

In more detail, this consists of the following.

The Sender posts a `ZapRequest`:

```json
{
  "kind": 61124,
  "tags": [
    ["e", <...>],     // Optional field indicating Zapped Note ID
    ["p", <...>],     // Pubkey of Zap Recipient
  ],
  "content": "{...}", // Zap amount, optional Zap comment
  ...
}
```

The Recipient Zapper listens to `ZapRequests` for its paired Client. When it sees one, it reacts by issuing an LN invoice with

- `amount_sat` set to the `amount` in the `ZapRequest`
- `expiry` set to 1 minute

and posts it as a `ZapInvoice`:

```json
{
  "kind": 61125,
  "tags": [
    ["e", <...>],   // Note ID of original ZapRequest
    ["p", <...>],   // Pubkey of Zap Sender
  ],
  "content": "...", // BOLT11
  ...
}
```

The Sender shows the invoice either as a QR code or as a `lightning://` link.

In the meantime, the Receiver is monitoring the invoice state for up to 1 minute. If it's paid in that time, it posts a `ZapReceipt`:

```json
{
  "kind": 1126,
  "tags": [
    ["e", <...>],     // Note ID of original ZapRequest
    ["p", <...>],     // Pubkey of Zap Recipient
  ],
  "content": "{...}", // Zap amount, optional Zap comment
  ...
}
```

## Showing and Sending Zaps

A Client MUST only show or tally Zaps from a paired Zapper.

A Client MUST only show a Zap button for Recipients with a paired Zapper.

Before showing a Zap invoice, the Client MUST validate that:

- the `ZapInvoice` `e` tag contains the original `ZapRequest` note ID
- the Zapper who sent the `ZapInvoice` is paired with the intended Recipient
- the invoice received is for the correct amount, in sats

Clients that only wish to tally the Zaps only need to query for `ZapReceipts`.


## Receiving Zaps

The Zapper SHOULD have a valid NIP-05 profile with a list of relays where it can be reached.


## Benefits vs. NIP-57

- No LNURL modifications needed
- Simpler clients: no parsing of BOLT11 or LNURL required
- Non-custodial friendly: no components need to be publicly reachable. No LN Address or LNURL endpoint needed. Therefore, anyone can run a Zapper (e.g. on an Umbrel) and start receiving Zaps.
- Lower footprint on relays: 2 ephemeral messages, only 1 persistent


## Weaknesses

- The Zapper is a trusted service. The `ZapReceipt` is only meaningful when the Recipient Zapper is honest. A dishonest Recipient can use a custom Zapper to "self-zap".

- When the Recipient changes to a different Zapper, this will cause the previously received Zaps to be lost. A viewer who wants to tally the Zaps will now query events signed by the new Zapper, meaning the previous ones are not counted.


## Future Work

- Once NIP-26 Signing Delegation is supported across relays, the Zapper should start using a delegated key. This way, changing to a new Zapper will keep previously received Zaps.
