# NIP-46 - Nostr Remote Signing

## Rationale

Private keys should be exposed to as few systems - apps, operating systems, devices - as possible as each system adds to the attack surface.

This NIP describes a method for 2-way communication between a remote signer and a Nostr client. The remote signer could be, for example, a hardware device dedicated to signing Nostr events, while the client is a normal Nostr client.

## Terminology

- **Local keypair**: A local public and private key-pair used to encrypt content and communicate with the remote signer.
- **Remote pubkey**: The public key that the user wants to sign as. The remote signer has control of the private key that matches this public key.

All pubkeys specified in this NIP are in hex format.

## Signer Discovery

To initiate a connection between a client and a remote signer there are a few different options.

### Direct connection initiated by remote signer

This is most common in a situation where you have your own nsecbunker or other type of remote signer and want to connect through a client that supports remote signing.

The remote signer would provide a connection token in the form:

```
bunker://<remote-pubkey>?relay=<wss://relay-to-connect-on>&relay=<wss://another-relay-to-connect-on>&secret=<optional-secret-value>
```

This token is pasted into the client by the user and the client then uses the details to connect to the remote signer via the specified relay(s).

### Direct connection initiated by the client

In this case, basically the opposite direction of the first case, the client provides a connection token (or encodes the token in a QR code) and the signer initiates a connection to the client via the specified relay(s).

```
nostrconnect://<local-keypair-pubkey>?relay=<wss://relay-to-connect-on>&metadata=<json metadata in the form: {"name":"...", "url": "...", "description": "..."}>
```

### Remote signer discovery via NIP-89

In this last case, most often used to fascilitate an OAuth-like signin flow, the client first looks for remote signers that have announced themselves via NIP-89 application handler events.

First the client will query for `kind: 31989` events that have a `k` tag of `24133`.

These are generally shown to a user, and once the user selects which remote signer to use and provides the remote pubkey they want to use (via npub, pubkey, or nip-05 value), the client can initiate a connection. Note that it's on the user to select the remote signer that is actually managing the remote key that they would like to use in this case. If the remote pubkey is managed on another remote signer, the connection will fail.

In addition, it's important that clients validate that the pubkey of the announced remote signer matches the pubkey of the `_` entry in the `/.well-known/nostr.json` file of the remote signer's announced domain.

Clients that allow users to create new accounts should also consider validating the availability of a given username in the namespace of remote signer's domain by checking the `/.well-known/nostr.json` file for existing usernames. Clients can then show users feedback in the UI before sending a `create_account` event to the remote signer and receiving an error in return. Ideally, remote signers would also respond with understandable error messages if a client tries to create an account with an existing username.

## The flow

### Client-side

1. Clients need several things to start: a local keypair and the details of the pubkey and remote signer the user would like to use.
   - The local keypair is roughly disposable. E.g. - it's ok to store it locally (ideally encrypted) for some period of time. Once authenticated, remote signers can choose to trust this local keypair for a period of time. This local keypair can be deleted/rotated at will by the client and will only trigger a new auth challenge or permissions on the remote signer.
   - The remote pubkey is the pubkey that the user is trying to sign in / sign as. This can be fetched with an NIP-05 or entered directly by the user (e.g. by passing a `bunker://` token).
2. Clients use the local keypair for encrypting request events that they send to remote signers.

### Remote signer-side

1. Remote signers manage the private key of the user that will be used for signing. There are many different remote signers out there (e.g. Nsecbunker, Amber, etc.) that operate in different ways and have different features.
2. Remote signers wait for request events and then act.

### Example flow for signing an event

Coming soon...

### Example Oauth-like flow to create a new user account with Nsecbunker

Coming soon...

## Request Events `kind: 24133`

```json
{
    "id": <id>,
    "kind": 24133,
    "pubkey": <local_keypair_pubkey>,
    "content": <nip04(<request>)>,
    "tags": [["p", <remote pubkey>]],
    "created_at": <unix timestamp in seconds>,
}
```

The `content` field is a JSON-RPC-like message that is [NIP-04](https://github.com/nostr-protocol/nips/blob/master/04.md) encrypted and has the following structure:

```json
{
    "id": <random_string>,
    "method": <method_name>,
    "params": [array_of_strings]
}
```

- `id` is a random string that is a request ID. This same ID will be sent back in the response payload.
- `method` is the name of the method/command (detailed below).
- `params` is a positional array of string parameters.

### Methods/Commands

Each of the following are methods that the client sends to the remote signer.

| Command                  | Params                                            | Result                                                                 |
| ------------------------ | ------------------------------------------------- | ---------------------------------------------------------------------- |
| `create_account`         | `[<username>, <domain>, <optional_email>]`        | `<newly_created_remote_pubkey>`                                        |
| `connect`                | `[<remote_pubkey>, <optional_secret>]`            | "ack"                                                                  |
| `sign_event`             | `[<json_stringified_event_to_sign>]`              | `json_stringified(<signed_event>)`                                     |
| `ping`                   | `[]`                                              | "pong"                                                                 |
| `get_relays`             | `[]`                                              | `json_stringified({<relay_url>: {read: <boolean>, write: <boolean>}})` |
| `get_public_key`         | `[]`                                              | `<hex-pubkey>`                                                         |
| `nip04_encrypt`          | `[<third_party_pubkey>, <plaintext_to_encrypt>]`  | `<nip04_ciphertext>`                                                   |
| `nip04_decrypt`          | `[<third_party_pubkey>, <ciphertext_to_decrypt>]` | `<plaintext>`                                                          |
| `nip44_conversation_key` | `[<third_party_pubkey>]`                          | `<nip44_conversation_key>`                                             |
| `nip44_encrypt`          | `[<third_party_pubkey>, <plaintext_to_encrypt>]`  | `<nip44_ciphertext>`                                                   |
| `nip44_decrypt`          | `[<third_party_pubkey>, <ciphertext_to_decrypt>]` | `<plaintext>`                                                          |

## Response Events `kind:24133`

```json
{
    "id": <id>,
    "kind": 24133,
    "pubkey": <remote_signer_pubkey>,
    "content": <nip04(<response>)>,
    "tags": [["p", <local keypair pubkey>]],
    "created_at": <unix timestamp in seconds>,
}
```

The `content` field is a JSON-RPC-like message that is [NIP-04](https://github.com/nostr-protocol/nips/blob/master/04.md) encrypted and has the following structure:

```json
{
    "id": <request_id>,
    "result": <results_string>,
    "error": <error_string>
}
```

- `id` is the request ID that this response is for.
- `results` is a string of the result of the call (this can be either a string or a JSON stringified object)
- `error` is an error in string form.

### Auth Challenges

An Auth Challenge is a response that a remote signer can send back when it needs the user to authenticate via other means. This is currently used in the OAuth-like flow enabled by signers like [Nsecbunker](https://github.com/kind-0/nsecbunkerd/). The response `content` object will take the following form:

```json
{
    "id": <request_id>,
    "result": "auth_url",
    "error": <URL_to_display_to_end_user>
}
```

Clients should display (in a popup or new tab) the URL from the `error` field and then subscribe/listen for another response from the remote signer (reusing the same request ID). This event will be sent once the user authenticates in the other window (or will never arrive if the user doesn't authenticate).

## References

- [NIP-04 - Encryption](https://github.com/nostr-protocol/nips/blob/master/04.md)
