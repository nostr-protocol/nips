NIP-43
======

Shared Key DM
-------------

`draft` `optional`

This direct message (DM) scheme between two participants aims to hide metadata while keeping the regular client-relay filtering experience.

## Chat Request

When an user sends a DM to someone for the first time, a `kind:1043` "Chat Request" event is also sent from user A to B.

If user A has never received a reply DM from B after some time,
or a new DM from user A was sent after a long period of chat inactivity,
user A's client may send another "Chat Request" event to B just in case a previous chat request was missed
due to being mixed with a lot of other chat requests by different people.

The chat request uses a random pubkey to hide from the public who's the requester, like a [NIP-59](59.md) Gift Wrap
but with a specific kind number to enable targeted fetch. It wraps a `kind:13` event that seals a `kind:1044` "Chat Request Intent" event.

The seal can only be opened using A and B keys, a fact that sets the participants.
While the most inner event kind number confirms that the intention is to chat.

The `kind:1044` event doesn't have a `.sig` field to prevent the event without seal
from proving authorship or being republished on relays.

It has an empty `.content` to reduce value for spammers (there is no attached message to show to the receiver).

It must have the same `created_at` of the `kind:1043` one to prevent
the latter's content from being replayed inside a new `kind:1043` event.

The "Chat Request" event should be sent to atleast one of the receiver's [NIP-65](65.md) `read` relays.

Relays should block chat request events with byte size higher than 3KB (1543 is the expected upper limit of the byte size of such events).

Relays are encouraged to require increasing [NIP-13](13.md) PoW difficulty the more chat requests are sent to the same pubkey.

Receiving clients MUST ignore chat requests with PoW difficulty lower than 16.

```js
{
  "kind": 1043,
  "pubkey": "<random-pubkey>",
  "tags": [
    ["p", "<pubkey-B>"],
    ["nonce", "65962", "16"] // atleast 16 PoW difficulty
  ],
  "content": "<nip44Encrypt(JSON.stringify({
    "kind": 13, // seal
    "pubkey" "<pubkey-A>",
    "tags": [],
    "content": "<nip44Encrypt(JSON.stringify({
      "kind": 1044,
      "pubkey" "<pubkey-A>",
      "tags": [],
      "content": "",
      "created_at": 1702711000 // now
      // ....other fields without .sig
    }))>",
    "created_at": 0
    // ....other fields
  }))>",
  "created_at": 1702711000 // now
  // ...other fields
}
```

## Approved Chats

When receiving a chat request from user A, an user B can accept it or ignore it.
The user accepts it by adding the sender's pubkey to its [NIP-51](51.md) `kind:10043`
"Approved Chats" event's list of encrypted `p` tags.

B's client should auto accept it if A is one of its follows or contact. Else
the client should show A's `kind:0` metadata and link to its profile to help with B decision.

When sending a chat request, the sender auto adds the receiver's pubkey to its own "Approved Chats" event.

The user should publish the event to all of its [NIP-65](65.md) `write` relays.

```js
{
  "kind": 10043,
  "pubkey": "<pubkey-B>"
  "content": "<nip44Encrypt(JSON.stringify([
    ["p", "<pubkey-A>"],
    // other "p" tags
  ]))>",
  // ...other fields
}
```

## Direct Message

After initiating a chat request and updating its own approved chats list, user A is free to send `kind:14` Shared Key DM events
even though it doesn't know if B will ever fetch and read them.

Both A and B use their [NIP-44](44.md) "Conversation Key" they have in common as a private key to sign a [NIP-59](59.md) `kind:1059` wrapper event
(with `kind:13` seal). It wraps the encrypted DM event authored by the real user's pubkey.

The "Conversation Key" is also used to encrypt the most inner events.

The wrapper event has a random pubkey on the `p` tag just to look like a regular gift wrap.
In reality the two participants will fetch messages by `author`, using the pubkey derived from the "Conversation Key".
This way no fake events can be sent to any of the participants to flood them with a DoS attack and the new messages set is downloaded quicker.

The correct current date is used on the wrapper event.

The inner `kind:14` event MUST NOT include a `.sig` field.

```js
{
  "kind": 1059, // gift wrap
  "pubkey": "<conversation-key-AB-derived-pubkey>",
  "tags": [
    ["p", "<random-pubkey>"] // just to look like a regular gift wrap
  ],
  "content": "<nip44Encrypt(JSON.stringify({
    "kind": 13, // seal
    "pubkey" "<pubkey-A>",
    "tags": [],
    "content": "<nip44Encrypt(JSON.stringify({
      "kind": 14, // DM
      "pubkey" "<pubkey-A>",
      "tags": [],
      "content": "Hello, User B",
      "created_at": 1702711000 // now
      // ....other fields without .sig
    }))>",
    "created_at": 0
    // ....other fields
  }))>",
  "created_at": 1702711000 // now
  // ...other fields
}
```

This event should be sent to atleast one of the receiver's [NIP-65](65.md) `read` relays and also to one or more of the sender's `read` relays.
This way, an user will only have to fetch DMs from its own set of `read` relays.
