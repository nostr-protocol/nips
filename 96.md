NIP-96
======

HTTP File Storage Integration
-----------------------------

`draft` `optional` `author:arthurfranca` `author:Semisol` `author:staab`

## Introduction

This NIP defines a REST API for HTTP file storage servers so to integrate them to the nostr network.
The API will enable nostr users to upload files and later reference them by url on nostr notes.

The spec DOES NOT use regular nostr events through websockets for
storing, requesting nor retrieving data because, for simplicity, the server
will not have to learn anything about nostr relays.

However, if a relay wants to also act as a file storage server, it should add NIP-96 to [NIP-11](11.md)
`supported_nips` field.

## Server Adaptation

File storage servers wishing to be accessible by nostr users should opt-in by making available
an https route at `/.well-known/nostr.json` with `nip96.routes` field in the following form:

```js
{
  "nip96": {
    // required
    "routes": {
      "upload": "https://upload.domain/upload-path",
      "download": "https://download.domain/download-path",
      "deletion": "https://deletion.domain/deletion-path"
    }
    // optional
    "max_byte_size": 10485760,
    // optional
    "file_expiration": "30 days if not much requested or if no NIP-60 customers",
    // optional
    "upload_cost": "free",
    // optional
    "image_transformations": ["resizing"],
    // optional
    "nip_integrations": [60] // e.g.: NIP-60
  },
  // optional
  "nip60": {
    "fee": "5% or 10000 sats"
  }
}
```

Note that if using a CDN, the `server` should issue a 302 redirect from
the `nip96.routes.download` route to the CDN url instead
of assigning the CDN directly as the `nip96.routes.download` route.
This is because some NIP-96 integrations, such as NIP-60 zap gates,
may require NIP-98 authentication for downloads,
which the CDN won't be able to support.

### List of Supporting File Storage Servers

| Name | Domain |
| ---- | ------ |
| -    | -      |

## Upload

A file can be uploaded one at a time to `https://upload.domain/upload-path` (route from `https://server.example.domain/.well-known/nostr.json`) as `multipart/form-data` content type using `POST` method with the file object set to the `file` form data field.

`Clients` must add a [NIP-98](98.md) `Authorization` header with the encoded `payload` tag set to the base64-encoded 256-bit SHA-256 hash of the file (not the hash of the whole request body).
If using an html form, use an `Authorization` form data field instead.

These following **optional** form data fields MAY be used by `servers` and SHOULD be sent by `clients`:
- `expiration`: string of the UNIX timestamp in seconds. Empty string if file should be stored forever. The server isn't required to honor this;
- `size`: string of the file byte size. This is just a value the server can use to reject early if the file size exceeds the server limits;
- `alt`: strict description text for visibility-impaired users;
- `caption`: loose description.

Others custom form data fields may be used depending on specific `server` support.
The `server` isn't required to store any metadata sent by `clients`.

Note for `clients`: if using an HTML form, it is important for the `file` form field to be the **last** one, or be re-ordered right before sending or be appended as the last field of XHR2's FormData object.

The `filename` embedded in the file may not be honored by the `server`, which could internally store just the SHA-256 hash value as the file name, ignoring extra metadata.
The hash is enough to uniquely identify a file, that's why it will be used on the "download" and "delete" routes.

The `server` MUST link the user's `pubkey` string (which is embedded in the decoded header value) as the owner of the file so to later allow him to delete the file.
Note that if a file with the same hash of a previously received file (so the same file) is uploaded by another user, the server doesn't need to store the new file.
It should just add the new user's `pubkey` to the list of the owners of the already stored file with said hash.

The `server` SHOULD also store the `Authorization` header/field value (decoded or not) for accountability purpose as this proves that the user with the unique pubkey did ask for the upload.

The `server` MUST reject with 413 Payload Too Large if file size exceeds limits.

The `server` MUST reject with 400 Bad Request status if some fields are invalid.

The `server` MUST reject the upload with 403 Forbidden status if the `payload` tag value contains an already used SHA-256 hash (if file is already owned by the same pubkey) or it isn't the same of the received file.

The `server` MAY reject the upload with 402 Payment Required status if the user has a pending payment (Although payment flow is not strictly required. Server owners decide if the storage is free or not. Although we suggest [this freemium monetization scheme](#monetization))

The upload response is a json as follows:

```js
{
  nip96: {
    // same from /.well-known/nostr.json's nip96.routes.download field
    download_route: "download.domain/download-path",
    // SHA-256 hash. Empty string if unsuccessful
    x: "719171db19525d9d08dd69cb716a18158a249b7b3b3ec4bbdec5698dca104b7b",
  },
  errors: {
    // Empty array if successful
    nip96: ['error 1', 'error 2']
  }
}
```

`Clients` may upload the same file to one or many `servers`.
After successful upload, the `client` may optionally generate and send to any set of nostr `relays` a [NIP-94](94.md) event with atleast these tags (please read the included comments):

```js
[
  // Note we appended .png from the original uploaded file extension to the received `x` value
  // (it is optional but extremely recommended to add the extension as it will help nostr clients with detecting the file type by using regular expression)
  ["url", "https://download.domain/download-path/719171db19525d9d08dd69cb716a18158a249b7b3b3ec4bbdec5698dca104b7b.png"],
  [
    "x",
    "719171db19525d9d08dd69cb716a18158a249b7b3b3ec4bbdec5698dca104b7b",
    // Server hostname where one can find the /.well-known/nostr.json config resource.
    "https://server.example.domain"
  ]
]
```

The `x` tag's third value is an important hint that clients can use to find new NIP-96 compatible file storage servers.

Alternativelly, instead of using NIP-94, the `client` can share or embed on a nostr note just the above url with added "x" [NIP-54](54.md) inline metadata field values and optionally other fields such as "magnet".

### File compression

File compression is optionally done at the `client`, **never on server**, before uploading.
This is done to assure the same file hash result, no matter to how many servers one may upload the same file.

## Download

`Servers` must make available the route `https://download.domain/download-path/<sha256-file-hash>(.ext)` (route from `https://server.example.domain/.well-known/nostr.json`) with `GET` method for file download.

Supporting ".ext", meaning "file extension", is required for `servers`. It is optional, although recommended, for `clients` to append it to the path.
When present it may be used by `servers` to know which `Content-Type` header to send (e.g.: "Content-Type": "image/png" for ".png" extension).
The file extension may be absent because the hash is the only needed string to uniquely identify a file.

Example: `https://download.domain/download-path/719171db19525d9d08dd69cb716a18158a249b7b3b3ec4bbdec5698dca104b7b.png`

### Image Transformations

`Servers` may respond to some image transformation query parameters and ignore those they don't support by serving
the original image file without transformations.

#### Resizing

Upon upload, `servers` may create resized image variants, such as thumbnails, respecting the original aspect ratio.
`Clients` may use the `w` query parameter to request an image version with the desired pixel width.
`Servers` can then serve the variant with the closest width to the parameter value
or an image variant generated on the fly.

Example: `https://download.domain/download-path/<sha256-file-hash>.png?w=32`

## Deletion

`Servers` must make available the route `https://deletion.domain/deletion-path/<sha256-file-hash>(.ext)` (route from `https://server.example.domain/.well-known/nostr.json`) with `DELETE` method for file deletion.
The extension is optional as the file hash is the only needed file identification.

`Clients` should send a `DELETE` request to the server url in the format `https://deletion.domain/deletion-path/<sha256-file-hash>.png`. It must include a NIP-98 `Authorization` header.

The `server` should reject deletes from users other than the original uploader. The `pubkey` encoded on the header value identifies the user.

It should be noted that more than one user may have uploaded the same file (so with the same hash). In this case, a delete must not really delete the file but just remove the user's `pubkey` from the file owners list.

The response is similar to the json sent on uploads, but without the `nip96.download_route` field.

## Monetization

This is an **optional** step that may be configured by `servers` at any moment.
It is a suggested way of monetizing the file storage.

It is a freemium business model, meaning that the file storage is free,
but it is expected that some users consuming the stored files may "zap" (send)
a variable amount of cryptocurrency to the server owner wallet.

Although file storage is free of charge, of course the `server` can delete files at any moment at its discrition.

For example, the file storage `server` may fetch [zap receipts](57.md#appendix-e-zap-receipt-event) from it's zap provider pubkey and
extract embeded media from referenced notes. Then stored files that hasn't received zaps
for a while may be deleted.

### Server Configuration

`Server` owners should configure their nostr pubkey at the `/.well-known/nostr.json?name=_` path as per [NIP-05](05.md#showing-just-the-domain-as-an-identifier), including `relay` information.

`Server` owners then should add to their nostr account metadata event (kind 0) a lud06 or lud16 field (and/or any future supported cryptocurrency address) pointing to a `zap-enabled` wallet address they own.

It is required to send the event to all relays included on previous NIP-05 configuration. We suggest re-sending the same event to said relays from time to time to make sure they don't get deleted.

### Client Implementation

`Clients` who make `zaps` available to their users are expected to try accessing the `/.well-known/nostr.json?name=_` path of all downloaded media domains from the NIP-94 `x` tag's third element or corresponding NIP-54 fragment field and, if available, get the zap related metadata (such as lud06 address).

Then they should cache this link between domains and zap-enabled pubkeys (or lack of). The individual cache entries should be renewed if too old.

When creating a nostr note with one or more embedded files from zap-enabled server(s), the client should add the media domain pubkeys to [zap tags](57.md#appendix-g-zap-tag-on-other-events), along with the note author's pubkey.

If more than one wallet address is detected for a nostr note, zap splits can take place if Nostr Wallet Connect is configured by the user (as per [NIP-47](47.md)).

If NIP-47 isn't configured, one of the addresses may be randomly chosen to receive the zap,
which is statistically fair (it is better than expecting user to pay many invoices at once because it would be bad UX) or simply choose the address with higher zap split weight.

## NIP-60 Zap Gates Integration

This is optional. `Servers` may restrict access to uploaded files to paying users using [NIP-60](60.md) flow.

### Upload

On upload, an extra `nip60` form data field must be sent by `clients` with an incomplete kind `1063` NIP-94
**stringified json** inside an `unsigned_event` field as value.
It must have `amount`, `relays` and atleast one `zap` tag (with the same meanings from NIP-57).
It may have a `preview` tag to be later shown while user hasn't payed for file access yet. For example:

```js
{
  // ...,
  nip60: JSON.stringify({
    // id, kind, pubkey, created_at and sig should be ignored by the server if present
    unsigned_event: {
      "tags": [
        ["m", "nostr/30023"], // optional. useful if it can't be inferred from file extension (e.G.: kind 30023 NIP-23 event json)
        ["preview", "<preview url/text>", "<MIME type>"],
        ["amount", "<price in milisats>"],
        // list of relays the recipient's wallet should publish its zap receipt to
        // and will be used by the file storage server to check if user has payed for content (check kind 9735 zap receipts)
        ["relays", "<relay url 1>", "<relay url 2>"],
        // payment destination according to NIP-57 zap splits
        // add it even if it is only the author
        ["zap", "<user pubkey>", "<relay hosting user kind 0 event>", "1"]
      ],
      "content": "<description>"
    }
  })
}

```

The `server` may reject the upload with 401 Unauthorized if the nip60 field is invalid.

The `server` may reject the upload if the price is too low considering the `server` fee it wants on zap splits. In this case
it must respond with a 400 Bad Request status.

The upload response contains the unsigned kind `1063` event with all previously missing fields filled.
The server may alter `zap` tags to add its revenue share fee.
It also must add `url`, `x` and `nip60` tags (the latter signals
to the viewing `client` that it is a paywalled content, so it requires zap payment and NIP-98 auth).
For example:

```js
{
  nip96: {
    // SHA-256 hash. Empty string if unsuccessful
    x: "719171db19525d9d08dd69cb716a18158a249b7b3b3ec4bbdec5698dca104b7b",
  },
  nip60: {
    // no sig
    unsigned_event: {
      "id": "<32-bytes lowercase hex-encoded sha256 of the the serialized event data>",
      "pubkey": "<user pubkey>", // the same as the NIP-98 user pubkey
      "created_at": "<unix timestamp in seconds>",
      "kind": 1063,
      "tags": [
        // e.g.: the json of a paywalled kind 30023 NIP-23 event
        // the server is advised to add the extension to the url value, although optional
        ["url", "https://download.domain/download-path/719171db19525d9d08dd69cb716a18158a249b7b3b3ec4bbdec5698dca104b7b.json"],
        ["x", "719171db19525d9d08dd69cb716a18158a249b7b3b3ec4bbdec5698dca104b7b", "https://server.example.domain"],
        ["nip60", "1"], // "1" meaning boolean true
        ["m", "nostr/30023"],
        // if the client didn't set a preview or blurhash tag, the server may add one
        ["preview", "<preview url/text>", "<MIME type>"],
        // if it is an image and both the preview and blurhash tags are absent, the server may add a blurhash tag
        // ["blurhash", "LKN]Rv%2Tw=w]~RBVZRi};RPxuwH"]
        ["amount", "<price in milisats>"],
        ["relays", "<relay url 1>", "<relay url 2>"]
        ["zap", "<user pubkey>", "<relay hosting user kind 0 event>", "19"], // notice the weight was altered by server
        ["zap", "<server pubkey>", "<relay hosting server kind 0 event>", "1"], // 5% server fee (revenue share)
      ],
      "content": "<description>",
    }
  },
  errors: {
    nip96: ['error 1', 'error 2'], // Empty array if successful
    nip60: ['error 1', 'error 2']  // Empty array if successful
  }
}
```

The `client` should then post a zap gated resource event, which is simply the unaltered above NIP-94 kind `1063` event
with signature [NIP-60](60.md). For example:

```js
{
  "id": "<32-bytes lowercase hex-encoded sha256 of the the serialized event data>",
  "pubkey": "<32-bytes lowercase hex-encoded public key of the user>",
  "created_at": "<unix timestamp in seconds>",
  "kind": 1063,
  "tags": [
    ["url", "https://download.domain/download-path/719171db19525d9d08dd69cb716a18158a249b7b3b3ec4bbdec5698dca104b7b.json"],
    ["x", "719171db19525d9d08dd69cb716a18158a249b7b3b3ec4bbdec5698dca104b7b", "https://server.example.domain"],
    ["nip60", "1"],
    ["m", "nostr/30023"],
    ["preview", "<preview url/text>", "<MIME type>"],
    ["amount", "<price in milisats>"],
    ["relays", "<relay url 1>", "<relay url 2>"]
    ["zap", "<user pubkey>", "<relay hosting user kind 0 event>", "19"],
    ["zap", "<server pubkey>", "<relay hosting server kind 0 event>", "1"]
  ],
  "content": "<description>",
  "sig": "<signature>" // signed with private key linked to the above pubkey
}
```

### Download

The `server` serves downloads as usual but it additionally requires authentication using NIP-98.
The event encoded on `Authorization` header should be similar to the following:

```js
{
  "id": "<32-bytes lowercase hex-encoded sha256 of the the serialized event data>",
  "pubkey": "<32-bytes lowercase hex-encoded public key of the user>",
  "created_at": "<unix timestamp in seconds>",
  "kind": 27235,
  "tags": [
    [
        "u",
        "https://download.domain/download-path/719171db19525d9d08dd69cb716a18158a249b7b3b3ec4bbdec5698dca104b7b.json" // with or without the extension
    ],
    [
        "method",
        "GET"
    ]
  ],
  "content": "",
  "sig": "<64-bytes hex of the signature of the sha256 hash of the serialized event data, which is the same as the id field>"
}
```

The `server` should check if the pubkey has already payed for the content, i.e., the sum of the related NIP-57 zap receipts
must be greater than or equal to the price set on upload and the `server` must have received its share.

Its advisable to store payer pubkeys so to fast check next time if the user is authorized to download the file.

These receipts must have these requirements:
- are valid according to [NIP-57 - Appendix G](57.md#appendix-f-validating-zap-receipts);
- the `e` tag is the kind `1063` event id defined on upload;
- the `p` tag is one of the pubkeys from the kind `1063` `zap` tags;
- `pubkey` field value is the `nostrPubkey` from NIP-57 protocol flow step 1 (using the lud06/lud16 from `zap` tag pubkeys' kind 0 profile).

If the user isn't authorized, the `server` must respond with 402 Payment Required status.
