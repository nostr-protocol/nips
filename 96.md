NIP-96
======

HTTP File Storage Integration
-----------------------------

`draft` `optional` `author:arthurfranca` `author:Semisol` `author:staab` `author:v0l` `author:bndw` `author:michaelhall923` `author:fishcakeday` `author:quentintaranpino`

## Introduction

This NIP defines a REST API for HTTP file storage servers intended to be used in conjunction with the nostr network.
The API will enable nostr users to upload files and later reference them by url on nostr notes.

The spec DOES NOT use regular nostr events through websockets for
storing, requesting nor retrieving data because, for simplicity, the server
will not have to learn anything about nostr relays.

## Server Adaptation

File storage servers wishing to be accessible by nostr users should opt-in by making available an https route at `/.well-known/nostr/nip96.json` with `api_url`:

```js
{
  // Required
  // File upload and deletion are served from this url
  // Also downloads if "download_url" field is absent or empty string
  "api_url": "https://your-file-server.example/custom-api-path",
  // Optional
  // If absent, downloads are served from the api_url
  "download_url": "https://a-cdn.example/a-path",
  // Optional
  // Note: This field is not meant to be set by HTTP Servers.
  // Use this if you are a nostr relay using your /.well-known/nostr/nip96.json
  // just to redirect to someone else's http file storage server's /.well-known/nostr/nip96.json
  // In this case, "api_url" field must be an empty string
  "delegated_to_url": "https://your-file-server.example",
  // Optional
  "supported_nips": [],
  // Optional
  "tos_url": "https://your-file-server.example/terms-of-service",
  // Optional
  "content_types": ["image/jpeg", "video/webm"]
  // Optional
  "plans": {
    // "free" is the only standardized plan key and
    // clients may use its presence to learn if server offers free storage
    "free": {
      "name": "Free Tier",
      "url": "https://...", // payment etc
      "max_byte_size": 10485760,
      // Range in days / 0 for no expiration
      // [7, 0] means it may vary from 7 days to unlimited persistence,
      // [0, 0] means it has no expiration
      // early expiration may be due to low traffic or any other factor
      "file_expiration": [14, 90],
      "image_transformations": ["resizing"]
    }
  }
}
```

### Relay Hints

Note: This section is not meant to be used by HTTP Servers.

A nostr relay MAY redirect to someone else's HTTP file storage server by
adding a `/.well-known/nostr/nip96.json` with "delegated_to_url" field
pointing to the url where the server hosts its own
`/.well-known/nostr/nip96.json`. In this case, the "api_url" field must
be an empty string and all other fields must be absent.

If the nostr relay is also an HTTP file storage server,
it must use the "api_url" field instead.

### List of Supporting File Storage Servers

| Name | Domain |
| ---- | ------ |
| -    | -      |

## Upload

A file can be uploaded one at a time to `https://your-file-server.example/custom-api-path` (route from `https://your-file-server.example/.well-known/nostr/nip96.json` "api_url" field) as `multipart/form-data` content type using `POST` method with the file object set to the `file` form data field.

`Clients` must add an [NIP-98](98.md) `Authorization` header (**optionally** with the encoded `payload` tag set to the base64-encoded 256-bit SHA-256 hash of the file - not the hash of the whole request body).
If using an html form, use an `Authorization` form data field instead.

These following **optional** form data fields MAY be used by `servers` and SHOULD be sent by `clients`:
- `expiration`: string of the UNIX timestamp in seconds. Empty string if file should be stored forever. The server isn't required to honor this;
- `size`: string of the file byte size. This is just a value the server can use to reject early if the file size exceeds the server limits;
- `alt`: (recommended) strict description text for visibility-impaired users;
- `caption`: loose description;
- `media_type`: "avatar" or "banner". Informs the server if the file will be used as an avatar or banner. If absent, the server will interpret it as a normal upload, without special treatment;
- `content_type`: mime type such as "image/jpeg". This is just a value the server can use to reject early if the mime type isn't supported.


Others custom form data fields may be used depending on specific `server` support.
The `server` isn't required to store any metadata sent by `clients`.

Note for `clients`: if using an HTML form, it is important for the `file` form field to be the **last** one, or be re-ordered right before sending or be appended as the last field of XHR2's FormData object.

The `filename` embedded in the file may not be honored by the `server`, which could internally store just the SHA-256 hash value as the file name, ignoring extra metadata.
The hash is enough to uniquely identify a file, that's why it will be used on the "download" and "delete" routes.

The `server` MUST link the user's `pubkey` string (which is embedded in the decoded header value) as the owner of the file so to later allow them to delete the file.
Note that if a file with the same hash of a previously received file (so the same file) is uploaded by another user, the server doesn't need to store the new file.
It should just add the new user's `pubkey` to the list of the owners of the already stored file with said hash (if it wants to save space by keeping just one copy of the same file, because multiple uploads of the same file results in the same file hash).

The `server` MAY also store the `Authorization` header/field value (decoded or not) for accountability purpose as this proves that the user with the unique pubkey did ask for the upload of the file with a specific hash. However, storing the pubkey is sufficient to establish ownership.

The `server` MUST reject with 413 Payload Too Large if file size exceeds limits.

The `server` MUST reject with 400 Bad Request status if some fields are invalid.

The `server` MUST reply to the upload with 200 OK status if the `payload` tag value contains an already used SHA-256 hash (if file is already owned by the same pubkey) or reject the upload with 403 Forbidden status if it isn't the same of the received file.

The `server` MAY reject the upload with 402 Payment Required status if the user has a pending payment (Payment flow is not strictly required. Server owners decide if the storage is free or not. Monetization schemes may be added later to correlated NIPs.).

The upload response is a json object as follows:

```js
{
  // "success" or "error" if unsuccessful or "processing" (special case at "Delayed Processing" section)
  status: "success",
  nip96: {
    code: 200, // or other HTTP status code
    // Can be an empty string if successful or an error message otherwise
    message: "OK",
    // This uses the NIP-94 event format but DO NOT need
    // to fill some fields like "id", "pubkey", "created_at" and "sig"
    //
    // This holds the download url ("url"),
    // the ORIGINAL file hash before server transformations ("x")
    // the file hash after server transformations ("xx")
    // and optionally all file metadata the server wants to make available
    nip94_event: {
      // Required tags: "url", "x" (and "xx" if different from "x")
      tags: [
        // Can be same from /.well-known/nostr/nip96.json's "download_url" field
        // (or "api_url" field if "download_url" is absent or empty) with appended
        // original file hash.
        //
        // Note we appended .png file extension to the `x` value
        // (it is optional but extremely recommended to add the extension as it will help nostr clients
        // with detecting the file type by using regular expression)
        //
        // Could also be any url to download the file
        // (not using /.well-known/nostr/nip96.json's "download_url" prefix),
        // for load balancing purposes for example.
        ["url", "https://your-file-server.example/custom-api-path/719171db19525d9d08dd69cb716a18158a249b7b3b3ec4bbdec5698dca104b7b.png"],
        // SHA-256 hash of the ORIGINAL file, before transformations. Empty string if unsuccessful.
        // The server MUST store it even though it represents the ORIGINAL file because
        // users may try to download the transformed file using this value
        [
          "x",
          "719171db19525d9d08dd69cb716a18158a249b7b3b3ec4bbdec5698dca104b7b",
          // Server hostname where one can find the
          // /.well-known/nostr/nip96.json config resource.
          //
          // This value is an important hint that clients can use
          // to find new NIP-96 compatible file storage servers.
          "https://your-file-server.example"
        ],
        // SHA-256 hash of the saved file after any server transformations. Empty string if unsuccessful.
        // The server can but doesn't need to store this value, but it must be informed here.
        ["xx", "543244319525d9d08dd69cb716a18158a249b7b3b3ec4bbde5435543acb34443"],
        // Optional
        ["m", "image/png"]
        // Optional
        ["dim", "800x600"]
      ],
      content: ""
    }
  }
}
```

Note that if the server didn't apply any transformation to the received file, both `nip96.x` and `nip96.xx`
fields will have the same value. The server MUST link the saved file to the SHA-256 hash of the **original** file before any server transformations). The **original** file's SHA-256 hash will be used to identify the saved file when downloading or deleting it.

`Clients` may upload the same file to one or many `servers`.
After successful upload, the `client` may optionally generate and send to any set of nostr `relays` a [NIP-94](94.md) event by including the missing fields.

Alternatively, instead of using NIP-94, the `client` can share or embed on a nostr note just the above url with added "x" and other [NIP-54](54.md) inline metadata field values.

### Delayed Processing

Sometimes a server may place the uploaded file in a processing queue. In this case the server must reply with 202 Created and the following JSON:

```
{
  status: "processing",
  nip96: {
    code: 202,
    message: "Accepted",
    processing_url: "..."
  }
}
```

The `nip96.processing_url` field is an url the client can use to check if the processing is done.

If the processing isn't done, the server should reply at the `nip96.processing_url` url with 404 Not Found and the following JSON:

```
{
  // It must be "processing", not "error"
  status: "processing",
  nip96: {
    code: 404,
    message: "Not Found"
  }
}
```

When the processing is over, the server replies at the `nip96.processing_url` url with a regular successful 200 OK status JSON response already mentioned before.

### File compression

File compression and other transformations like metadata stripping can be applied by the server.
However, for all file actions, such as download and deletion, the **original** file SHA-256 hash is what identifies the file in the url string.

## Download

`Servers` must make available the route `https://your-file-server.example/custom-api-path/<sha256-file-hash>(.ext)` (route taken from `https://your-file-server.example/.well-known/nostr/nip96.json` "api_url" or "download_url" field) with `GET` method for file download.

Note that the "\<sha256-file-hash\>" part is from the **original** file, **not** from the **transformed** file if the uploaded file went through any server transformation.

Supporting ".ext", meaning "file extension", is required for `servers`. It is optional, although recommended, for `clients` to append it to the path.
When present it may be used by `servers` to know which `Content-Type` header to send (e.g.: "Content-Type": "image/png" for ".png" extension).
The file extension may be absent because the hash is the only needed string to uniquely identify a file.

Example: `https://your-file-server.example/custom-api-path/719171db19525d9d08dd69cb716a18158a249b7b3b3ec4bbdec5698dca104b7b.png`

### Image Transformations

`Servers` may respond to some image transformation query parameters and ignore those they don't support by serving
the original image file without transformations.

#### Resizing

Upon upload, `servers` may create resized image variants, such as thumbnails, respecting the original aspect ratio.
`Clients` may use the `w` query parameter to request an image version with the desired pixel width.
`Servers` can then serve the variant with the closest width to the parameter value
or an image variant generated on the fly.

Example: `https://your-file-server.example/custom-api-path/<sha256-file-hash>.png?w=32`

## Deletion

`Servers` must make available the route `https://deletion.domain/deletion-path/<sha256-file-hash>(.ext)` (route taken from `https://your-file-server.example/.well-known/nostr/nip96.json` "api_url" field) with `DELETE` method for file deletion.

Note that the "\<sha256-file-hash\>" part is from the **original** file, **not** from the **transformed** file if the uploaded file went through any server transformation.

The extension is optional as the file hash is the only needed file identification.

`Clients` should send a `DELETE` request to the server deletion route in the above format. It must include a NIP-98 `Authorization` header.

The `server` should reject deletes from users other than the original uploader. The `pubkey` encoded on the header value identifies the user.

It should be noted that more than one user may have uploaded the same file (with the same hash). In this case, a delete must not really delete the file but just remove the user's `pubkey` from the file owners list (considering the server keeps just one copy of the same file, because multiple uploads of the same file results
in the same file hash).

The successfull response is a 200 OK one with just basic JSON fields:

```
{
  status: "success",
  nip96: {
    code: 200,
    message: "OK"
  }
}
```

## Selecting a Server

Note: HTTP File Storage Server developers may skip this section. This is meant for client developers.

A File Server Preference event is a kind 10096 replaceable event meant to select one or more servers the user wants
to upload files to. Servers are listed as `server` tags:

```js
{
  // ...
  "kind": 10096,
  "content": "",
  "tags": [
    ["server", "https://file.server.one"],
    ["server", "https://file.server.two"]
  ]
}
```
